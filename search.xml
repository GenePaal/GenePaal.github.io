<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>339随机值日小程序源码</title>
    <url>/2020/09/04/339%E9%9A%8F%E6%9C%BA%E5%80%BC%E6%97%A5%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%BA%90%E7%A0%81/</url>
    <content><![CDATA[<p>为宿舍内公平值日设计的一个小程序（手动滑稽），点击“阅读全文”查看源码以及使用说明    </p>
<a id="more"></a>

<h2 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h2><ol>
<li>直接将下面的代码复制到C语言编译器里运行即可</li>
<li>每个人摇到几号，则周几值日，摇到8号的不用值日</li>
</ol>
<h2 id="源码附上"><a href="#源码附上" class="headerlink" title="源码附上"></a>源码附上</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max 20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">member</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="built_in">max</span>];</span><br><span class="line">    <span class="keyword">int</span> number;</span><br><span class="line">&#125; Member;</span><br><span class="line"></span><br><span class="line">Member arr[<span class="built_in">max</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>, j, i, flag, t;</span><br><span class="line">    <span class="built_in">strcpy</span>(arr[<span class="number">0</span>].name, <span class="string">"曹曾超"</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(arr[<span class="number">1</span>].name, <span class="string">"王梓臣"</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(arr[<span class="number">2</span>].name, <span class="string">"贾金澎"</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(arr[<span class="number">3</span>].name, <span class="string">"安凯晨"</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(arr[<span class="number">4</span>].name, <span class="string">"李艾兴"</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(arr[<span class="number">5</span>].name, <span class="string">"李政尧"</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(arr[<span class="number">6</span>].name, <span class="string">"郭艺萌"</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(arr[<span class="number">7</span>].name, <span class="string">"郝龙祥"</span>);</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">while</span> (s != <span class="number">8</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        flag = <span class="number">1</span>;</span><br><span class="line">        j = rand() % <span class="number">8</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; s; i++)</span><br><span class="line">            <span class="keyword">if</span> (arr[i].number == j)</span><br><span class="line">            &#123;</span><br><span class="line">                flag = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag)</span><br><span class="line">        &#123;</span><br><span class="line">            arr[s].number = j;</span><br><span class="line">            s++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d   %s\n"</span>, arr[i].number + <span class="number">1</span>, arr[i].name);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>日常应用小程序</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello, 2021</title>
    <url>/2021/01/01/Hello-2021/</url>
    <content><![CDATA[<center>回顾2020 展望2021</center>

<a id="more"></a>

<p></br>2020结束了，其实本来也没打算写点什么感悟，然后发空间啊发朋友圈啊什么的，后来想想还是写点吧，发自己博客上，这个博客除了我应该也不会有人看吧，hh</p>
<p>大学从来没有好好地学过一个东西，刚学会一点就觉得自己牛哄哄的，尾巴就飘上天了，还有就是感情，周期性地想情爱，周期性地tmd想搞女朋友，到最后也就是空空地在那里网抑云，耽误了时间耽误了精力，还整的自己精神状态非常不好，这是图了个啥。</p>
<p>2020年，自己始终没有从情爱中走出来，还是不能专注于自己的事业，虽然在学院里自己算得上是一名所谓的优秀的学生，学到了点东西，但是自己还是不行，做事情不专注，三心二意，也只有在中间的一段时间里，好好学了，然后仔细思考了，然后就是对他吗情爱的向往，最后依然单身，有个p用</p>
<p>希望在2021年，自己能一心一意地专注于自己的学业，暂时不要过多得去想情爱这个事情，思想单纯一些一心一意地去写代码搞事情，或许当你一心一意编程学习的时候，爱情就不请自来了呢hhh </p>
<p>就这样吧，2020年，虽然经常会三心二意为情爱所困，但是在不为它所困的时间里我还是学到了很多东西，写了不少算法代码，编程功底还是提高了不少。emm…就这样吧。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>新年好</tag>
      </tags>
  </entry>
  <entry>
    <title>Java代码执行顺序</title>
    <url>/2021/03/30/Java%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/</url>
    <content><![CDATA[<center>Java源文件中代码的加载顺序</center>

<a id="more"></a>

<h3 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h3><ol>
<li>对类的加载</li>
</ol>
<ul>
<li>加载类的方法和静态属性 为方法和静态属性分配空间</li>
<li>按照静态代码块和静态属性定义语句 在源文件中的顺序执行静态代码块中的操作和对属性的初始化(初始化默认赋0、null等)</li>
</ul>
<ol start="2">
<li>加载对象</li>
</ol>
<ul>
<li>当一个对象被初始化时，为对象开辟空间，给对象的非静态属性分配空间(不包括静态属性，静态属性属于类)</li>
<li>按照非静态属性定义语句和非静态代码块在源文件中的顺序执行对非静态属性的初始化和非静态代码块中的操作</li>
<li>执行构造方法</li>
</ul>
<h3 id="学习执行顺序的时候顺便复习了一下static"><a href="#学习执行顺序的时候顺便复习了一下static" class="headerlink" title="学习执行顺序的时候顺便复习了一下static"></a>学习执行顺序的时候顺便复习了一下<code>static</code></h3><p>静态成员方法的用处</p>
<ul>
<li>可以访问、修改静态变量，尤其是类的私有静态属性，如果类的静态属性是私有的，如果不设静态成员方法，那么在类外就无法访问这个私有静态属性了</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JavaBase</tag>
        <tag>Java变量加载顺序</tag>
      </tags>
  </entry>
  <entry>
    <title>Java枚举源码级理解</title>
    <url>/2020/11/08/Java%E6%9E%9A%E4%B8%BE%E6%BA%90%E7%A0%81%E7%BA%A7%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<center>Java中枚举体的一些东西很怪，看了源码之后恍然大悟，收获颇丰</center>

<a id="more"></a>

<p>废话不多说，直接上代码</p>
<h2 id="第一种形式"><a href="#第一种形式" class="headerlink" title="第一种形式"></a>第一种形式</h2><h3 id="枚举体定义"><a href="#枚举体定义" class="headerlink" title="枚举体定义"></a>枚举体定义</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Day &#123;</span><br><span class="line">	MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="枚举体使用"><a href="#枚举体使用" class="headerlink" title="枚举体使用"></a>枚举体使用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Day today = Day.MONDAY;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行Test类中的main方法之后，生成两个文件，分别是Day和Test的class文件</p>
<h3 id="反编译Day-class-只保留了本文研究所需部分"><a href="#反编译Day-class-只保留了本文研究所需部分" class="headerlink" title="反编译Day.class(只保留了本文研究所需部分)"></a>反编译Day.class(只保留了本文研究所需部分)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 反编译Day.class</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Day</span> <span class="keyword">extends</span> <span class="title">Enum</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//前面定义的7种枚举实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Day MONDAY;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Day TUESDAY;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Day WEDNESDAY;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Day THURSDAY;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Day FRIDAY;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Day SATURDAY;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Day SUNDAY;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Day $VALUES[];</span><br><span class="line">	<span class="keyword">static</span> </span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="comment">//实例化枚举实例</span></span><br><span class="line">        MONDAY = <span class="keyword">new</span> Day(<span class="string">"MONDAY"</span>, <span class="number">0</span>);</span><br><span class="line">        TUESDAY = <span class="keyword">new</span> Day(<span class="string">"TUESDAY"</span>, <span class="number">1</span>);</span><br><span class="line">        WEDNESDAY = <span class="keyword">new</span> Day(<span class="string">"WEDNESDAY"</span>, <span class="number">2</span>);</span><br><span class="line">        THURSDAY = <span class="keyword">new</span> Day(<span class="string">"THURSDAY"</span>, <span class="number">3</span>);</span><br><span class="line">        FRIDAY = <span class="keyword">new</span> Day(<span class="string">"FRIDAY"</span>, <span class="number">4</span>);</span><br><span class="line">        SATURDAY = <span class="keyword">new</span> Day(<span class="string">"SATURDAY"</span>, <span class="number">5</span>);</span><br><span class="line">        SUNDAY = <span class="keyword">new</span> Day(<span class="string">"SUNDAY"</span>, <span class="number">6</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//私有构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Day</span><span class="params">(String s, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(s, i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略了无关代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码第一行<code>final class Day extends Enum</code>我们可以知道Day类继承了Enum类，紧接着让我们看一下Enum的源码</p>
<h3 id="Enum类部分源码"><a href="#Enum类部分源码" class="headerlink" title="Enum类部分源码"></a>Enum类部分源码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Enum</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Enum</span>&lt;<span class="title">E</span>&gt;&gt; <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">E</span>&gt;, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name; <span class="comment">//枚举字符串名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> ordinal;<span class="comment">//枚举顺序值</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">//枚举的构造方法，只能由编译器调用</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Enum</span><span class="params">(String name, <span class="keyword">int</span> ordinal)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.ordinal = ordinal;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 虽然方法名不是getName 但不难看出这是name属性的get方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ordinal 的get方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">ordinal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ordinal;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略了无关代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此枚举体本质是一个类，其中的成员是它的对象。在编译的时候，先声明每个枚举出来的成员的引用，然后调用静态代码块，对每个成员引用实例化，实例化的时候用到了构造方法，构造方法传的参数是下标从0开始依次递增以及成员的名字，就好比是对象名 = 对象的属性name的字符串值，然后又给每个成员从0开始依次赋了下标</p>
<p>枚举的一切初始化都是在类 加载的时候完成的，在Test类中使用枚举体的时候，可以认为一切都已经准备好了，类中存着每个静态对象，直接类名.静态对象</p>
<p>正常使用的时候，我们需要先 <code>类名 对象名 = new 类名(参数...)</code>，枚举体和正常情况下的不同就在于它这个类在被加载出来的时候就已经拥有了实现列举的若干个静态对象，在使用的时候直接 <code>类名.静态对象名</code>就可以得到枚举体中枚举的对象(对，没错，这里得到的是对象，因为原来在C语言里也学过枚举体，我就沿用了C语言的思路，刚开始的时候我一直认为得到的是一个类似于C语言宏定义中一个名字实质是一个数，然而并不是，它是一个对象)，如果要得到对象的一些属性，目前用到的方法有 name方法和ordinal方法， 在Enum类的源码中都已列出。</p>
<h2 id="另一种形式"><a href="#另一种形式" class="headerlink" title="另一种形式"></a>另一种形式</h2><h3 id="向enum类中显式添加构造方法和自定义属性"><a href="#向enum类中显式添加构造方法和自定义属性" class="headerlink" title="向enum类中显式添加构造方法和自定义属性"></a><strong>向enum类中显式添加构造方法和自定义属性</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Day&#123;</span><br><span class="line">    MONDAY(<span class="string">"monday"</span>, <span class="number">1</span>), </span><br><span class="line">    TUESDAY = <span class="keyword">new</span> Day(<span class="string">"tuesday"</span>, <span class="number">2</span>),</span><br><span class="line">    WEDNESDAY = <span class="keyword">new</span> Day(<span class="string">"wednesday"</span>, <span class="number">3</span>),</span><br><span class="line">    THURSDAY = <span class="keyword">new</span> Day(<span class="string">"thursday"</span>, <span class="number">4</span>),</span><br><span class="line">    FRIDAY = <span class="keyword">new</span> Day(<span class="string">"friday"</span>, <span class="number">5</span>),</span><br><span class="line">    SATURDAY = <span class="keyword">new</span> Day(<span class="string">"saturday"</span>, <span class="number">6</span>),</span><br><span class="line">    SUNDAY = <span class="keyword">new</span> Day(<span class="string">"sunday"</span>, <span class="number">7</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Day</span><span class="params">(String desc, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.desc = desc;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对每个属性只设置get方法，enum不设set方法</span></span><br><span class="line">    <span class="comment">// 因为发明枚举体的初心是让它static且final</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.desc;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="反编译Day-class"><a href="#反编译Day-class" class="headerlink" title="反编译Day.class"></a>反编译Day.class</h3><p>该形式下的Day.class反编译之后的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Day</span> <span class="keyword">extends</span> <span class="title">Enum</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Day</span><span class="params">(String s, <span class="keyword">int</span> i, String desc, <span class="keyword">int</span> id)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(s, i);</span><br><span class="line">        <span class="keyword">this</span>.desc = desc;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDesc</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Day[] values()</span><br><span class="line">    &#123;</span><br><span class="line">        Day aday[];</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        Day aday1[];</span><br><span class="line">        System.arraycopy(aday = ENUM$VALUES, <span class="number">0</span>, aday1 = <span class="keyword">new</span> Day[i = aday.length], <span class="number">0</span>, i);</span><br><span class="line">        <span class="keyword">return</span> aday1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Day <span class="title">valueOf</span><span class="params">(String s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Day)Enum.valueOf(work/Day, s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Day MONDAY;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Day TUESDAY;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Day WEDNESDAY;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Day THURSDAY;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Day FRIDAY;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Day SATURDAY;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Day SUNDAY;</span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Day ENUM$VALUES[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> </span><br><span class="line">    &#123;</span><br><span class="line">        MONDAY = <span class="keyword">new</span> Day(<span class="string">"MONDAY"</span>, <span class="number">0</span>, <span class="string">"\u661F\u671F\u4E00"</span>, <span class="number">1</span>);</span><br><span class="line">        TUESDAY = <span class="keyword">new</span> Day(<span class="string">"TUESDAY"</span>, <span class="number">1</span>, <span class="string">"\u661F\u671F\u4E8C"</span>, <span class="number">1</span>);</span><br><span class="line">        WEDNESDAY = <span class="keyword">new</span> Day(<span class="string">"WEDNESDAY"</span>, <span class="number">2</span>, <span class="string">"\u661F\u671F\u4E09"</span>, <span class="number">2</span>);</span><br><span class="line">        THURSDAY = <span class="keyword">new</span> Day(<span class="string">"THURSDAY"</span>, <span class="number">3</span>, <span class="string">"\u661F\u671F\u56DB"</span>, <span class="number">3</span>);</span><br><span class="line">        FRIDAY = <span class="keyword">new</span> Day(<span class="string">"FRIDAY"</span>, <span class="number">4</span>, <span class="string">"\u661F\u671F\u4E94"</span>, <span class="number">4</span>);</span><br><span class="line">        SATURDAY = <span class="keyword">new</span> Day(<span class="string">"SATURDAY"</span>, <span class="number">5</span>, <span class="string">"\u661F\u671F\u516D"</span>, <span class="number">5</span>);</span><br><span class="line">        SUNDAY = <span class="keyword">new</span> Day(<span class="string">"SUNDAY"</span>, <span class="number">6</span>, <span class="string">"\u661F\u671F\u65E5"</span>, <span class="number">6</span>);</span><br><span class="line">        ENUM$VALUES = (<span class="keyword">new</span> Day[] &#123;</span><br><span class="line">            MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>是不是有点头疼…?  好多没见过的东西= =，所以，下面是删改版</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Day</span> <span class="keyword">extends</span> <span class="title">Enum</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Day</span><span class="params">(String s, <span class="keyword">int</span> i, String desc, <span class="keyword">int</span> id)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(s, i);</span><br><span class="line">        <span class="keyword">this</span>.desc = desc;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDesc</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Day MONDAY;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Day TUESDAY;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Day WEDNESDAY;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Day THURSDAY;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Day FRIDAY;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Day SATURDAY;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Day SUNDAY;</span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> </span><br><span class="line">    &#123;</span><br><span class="line">        MONDAY = <span class="keyword">new</span> Day(<span class="string">"MONDAY"</span>, <span class="number">0</span>, <span class="string">"monday"</span>, <span class="number">1</span>);</span><br><span class="line">        TUESDAY = <span class="keyword">new</span> Day(<span class="string">"TUESDAY"</span>, <span class="number">1</span>, <span class="string">"tuesday"</span>, <span class="number">1</span>);</span><br><span class="line">        WEDNESDAY = <span class="keyword">new</span> Day(<span class="string">"WEDNESDAY"</span>, <span class="number">2</span>, <span class="string">"wednesday"</span>, <span class="number">2</span>);</span><br><span class="line">        THURSDAY = <span class="keyword">new</span> Day(<span class="string">"THURSDAY"</span>, <span class="number">3</span>, <span class="string">"thursday"</span>, <span class="number">3</span>);</span><br><span class="line">        FRIDAY = <span class="keyword">new</span> Day(<span class="string">"FRIDAY"</span>, <span class="number">4</span>, <span class="string">"friday"</span>, <span class="number">4</span>);</span><br><span class="line">        SATURDAY = <span class="keyword">new</span> Day(<span class="string">"SATURDAY"</span>, <span class="number">5</span>, <span class="string">"saturday"</span>, <span class="number">5</span>);</span><br><span class="line">        SUNDAY = <span class="keyword">new</span> Day(<span class="string">"SUNDAY"</span>, <span class="number">6</span>, <span class="string">"sunday"</span>, <span class="number">6</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>看了源码是不是恍然大悟？哈哈哈</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>做个总结，枚举体不管是第一种写法还是第二种写法，它们都有一个特点就是在static代码块中调用的构造方法(这个构造方法也是遵循子父类机制的，若有父类就会在第一行隐式先调用父类的无参构造，父类若没有显示地写构造方法系统会自动给加上一个无参构造，因此就可以联系起来了)</p>
<p>static代码块中调用构造方法有一种特点，就是在类加载的过程中new对象，类加载好了之后已经是拥有了各个枚举成员对象的状态。</p>
<p>抛开这个枚举体，假设Day是一个正常的public class Day 对象</p>
<p>那么正常情况下我们都是在Day的外部类中的方法里new一个Day的对象， 下面叙述一下过程：(若Day有父类)加载父类的属性方法，并给属性赋上初值。(若父类有static代码块)执行父类的static代码块。加载本类的属性方法，并给属性赋上初值。(若本类有static代码块)执行本类的static代码块。  ———–这是一个分割线———— 前面的可以认为是类中所有对象共有的，静态的，这些东西只要类加载出来就会给它们分配内存，而后面的则是对象特有的，只有在把对象new出来才会分配空间(比如普通类的public属性)  ——-分割线———          (若有父类)执行父类的构造方法。 执行本类的构造方法。</p>
<p>扯了这么多我究竟想说什么呢？</p>
<p>我想说枚举体类是在类加载的过程中new对象的，因此它的类加载完了，对象也就实例化出来了，不知道你有没有想过，枚举体类加载完之后是不是还会继续先执行父类enum 的构造方法和自己的构造方法，这样不就重复调用了吗？不是的，之所以会有执行父类构造方法，执行子类构造方法这个过程是因为有对象被new出来，被new的同时肯定就会调用构造方法。枚举体只是在加载的过程中实例化了对象，后来并没有被new对象，因此也就不会再有执行父类的构造方法和执行子类的构造方法了。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JavaBase</tag>
        <tag>Java枚举</tag>
        <tag>源码理解</tag>
        <tag>Java源码理解</tag>
        <tag>枚举</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>KMP</title>
    <url>/2020/10/27/KMP/</url>
    <content><![CDATA[<p>KMP算法，代码写的不好看，也不简洁，自己手敲的，也算是开天辟地了</p>
<p>后续持续优化代码 + 思路详细讲解，只希望让后来者少踩坑，起码不要踩我踩过的坑 T^T</p>
<a id="more"></a>

<p>先附上代码，后续更新详细讲解</p>
<h5 id="非递归求next数组"><a href="#非递归求next数组" class="headerlink" title="非递归求next数组"></a>非递归求next数组</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 开始手写KMP   自我感觉还是不太好的</span></span><br><span class="line"><span class="comment">// 串的底层用静态数组实现</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_SIZE 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> str[MAX_SIZE];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLength</span><span class="params">(str)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">getNext</span><span class="params">(str)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    str S = <span class="string">"dab5cdabcdabdebdedabcd1abdedabcd6abde"</span>;</span><br><span class="line">    str T = <span class="string">"dabcdabde"</span>;</span><br><span class="line">    <span class="keyword">int</span> lengthT = getLength(T);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, lengthT);</span><br><span class="line">    <span class="keyword">int</span> lengthS = getLength(S);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, lengthS);</span><br><span class="line">    <span class="keyword">int</span> *next = getNext(T);</span><br><span class="line">    <span class="comment">// 打印next数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lengthT; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, next[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">int</span> i, j = <span class="number">0</span>, flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= lengthS - lengthT;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (T[j] &amp;&amp; (S[i] == T[j]))</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == lengthT)</span><br><span class="line">        &#123;</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        j = next[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, i - lengthT);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"找不到该子串\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLength</span><span class="params">(str T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (T[index++])</span><br><span class="line">        ;</span><br><span class="line">    <span class="keyword">return</span> index - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">getNext</span><span class="params">(str T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = getLength(T);</span><br><span class="line">    <span class="keyword">int</span> *next = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * length);</span><br><span class="line">    <span class="comment">// next数组的前两个</span></span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 当前字符的上一个字符的最大匹配数</span></span><br><span class="line">        <span class="keyword">int</span> k = next[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (T[k] == T[i - <span class="number">1</span>])</span><br><span class="line">            next[i] = k + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (next[k] != <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                k = next[k];</span><br><span class="line">                <span class="keyword">if</span> (T[k] == T[i - <span class="number">1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    next[i] = k + <span class="number">1</span>;</span><br><span class="line">                    flag = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (next[k] == <span class="number">-1</span> &amp;&amp; flag)</span><br><span class="line">                next[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="递归求next数组"><a href="#递归求next数组" class="headerlink" title="递归求next数组"></a>递归求next数组</h5><p>递归中很多参数可以改成全局变量，本着把它封装成函数的目的，我没有设全局变量</p>
<p>确实挺浪费内存</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 手写KMP</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 100</span></span><br><span class="line"><span class="comment">// 定义字符串的数据类型</span></span><br><span class="line"><span class="comment">// 0号空间使用，配有长度</span></span><br><span class="line"><span class="comment">// 使用的是字符型指针，所以字符串的最后边不会被系统默认加上 '\0'</span></span><br><span class="line"><span class="comment">// 所以需要一个变量length来表示字符串的长度</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> *str;</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">&#125;<span class="keyword">String</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">getNextArr</span><span class="params">(<span class="keyword">String</span>)</span></span>;</span><br><span class="line"><span class="comment">// 需要原来的next数组， 目标字符串, 当前求到第几个字符的next域了</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getEachValue</span><span class="params">(<span class="keyword">String</span>, <span class="keyword">int</span>*, <span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">String</span> s, t;</span><br><span class="line">    <span class="comment">// 在这里，直接让它指向那块不可被修改的字符串的内存了</span></span><br><span class="line">    <span class="comment">// 后面还是有 '\0' 的</span></span><br><span class="line">    s.str = <span class="string">"dab5cdabcdabdebdedabcd1abdedabcd6abde"</span>;</span><br><span class="line">    s.length = <span class="built_in">strlen</span>(s.str);</span><br><span class="line">    t.str = <span class="string">"dabcdabde"</span>;</span><br><span class="line">    t.length = <span class="built_in">strlen</span>(t.str);</span><br><span class="line">    <span class="comment">// 求next数组</span></span><br><span class="line">    <span class="keyword">int</span> *next = getNextArr(t);</span><br><span class="line">    <span class="comment">// 打印next数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.length; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, next[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">getNextArr</span><span class="params">(<span class="keyword">String</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *next = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * s.length);</span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; s.length; i++)</span><br><span class="line">        getEachValue(s, next, i - <span class="number">1</span>, i);</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getEachValue</span><span class="params">(<span class="keyword">String</span> s, <span class="keyword">int</span> *next, <span class="keyword">int</span> p, <span class="keyword">const</span> <span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = next[p];</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">-1</span>)</span><br><span class="line">        next[index] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (s.str[index - <span class="number">1</span>] == s.str[k])</span><br><span class="line">        next[index] = k + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        getEachValue(s, next, k, index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>DSandAL</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>KMP</tag>
        <tag>AL</tag>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>DS</tag>
      </tags>
  </entry>
  <entry>
    <title>OS记录型信号量-读者写者问题</title>
    <url>/2021/04/09/OS%E8%AE%B0%E5%BD%95%E5%9E%8B%E4%BF%A1%E5%8F%B7%E9%87%8F-%E8%AF%BB%E8%80%85%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<center>
        利用记录型信号量实现读者写者问题
</center>


<a id="more"></a>

<h2 id="写在最前"><a href="#写在最前" class="headerlink" title="写在最前"></a>写在最前</h2><p>最近对 OS 这门课着了迷，hhh，拿起课本就是硬啃</p>
<p>用了一段时间领悟了记录型信号量的几个版本</p>
<p>这是对记录型信号量的一个应用，那么 pv操作( 即wait()和signal() )的具体代码描述  肯定是要烂熟于心的</p>
<p>在这里我就不写书上那么详细了</p>
<p>在这里我唠叨几句，pv操作虽然简简单单的这几行代码，但是非常具有思考性，很多细节只有自己想通了，才能将pv操作“玩弄于鼓掌之上”</p>
<p>改篇详细介绍一下pv操作 和 里面值得思考的细节</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">wait(S) &#123;</span><br><span class="line">    S-&gt;value--;</span><br><span class="line">    <span class="keyword">if</span> (S-&gt;value &lt; <span class="number">0</span>) </span><br><span class="line">        block(S-&gt;<span class="built_in">list</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">signal(S) &#123;</span><br><span class="line">    S-&gt;value++;</span><br><span class="line">    <span class="keyword">if</span> (S-&gt;value &lt;= <span class="number">0</span>)</span><br><span class="line">        signal(S-&gt;<span class="built_in">list</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="初始版本"><a href="#初始版本" class="headerlink" title="初始版本"></a>初始版本</h2><p>为什么叫初始版本呢？ 因为它不公平，对读者友好，对写者十分不友好</p>
<p>我们知道读者写者问题中  读读操作是可以同时进行的，唯独写操作不可以与任何操作同时进行</p>
<p>可以进行的操作   单独读 多个同时读 单独写 ；同时读写 和 多个同时写 是不允许的</p>
<p>在这个版本中只有当所有的读者都不再占用文件的时候  写进程才有机会访问文件，光说没什么卵用</p>
<p>下面分析代码，细致地了解到底是怎么个情况，我会将分析对应地写到注释里</p>
<p>着重分析初始版本，因为后面实现读者写者公平的版本 仅仅是对它的一个改良</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  readcount 表示当前有几个读进程正在读文件</span></span><br><span class="line"><span class="keyword">int</span> readcount = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// rmutex 用于实现 读读进程 之间的互斥,保护readcount, 防止多个读进程同时访问/修改 readcount</span></span><br><span class="line"><span class="comment">// wmutext 用于实现 读写、写写之间的互斥,总之,一句话，用于实现某一个写进程和其它所有进程的互斥</span></span><br><span class="line">semaphore rmutex = <span class="number">1</span>, wmutex = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读进程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 占用 readcount</span></span><br><span class="line">        <span class="comment">// 可以理解为 给readcount "上锁"</span></span><br><span class="line">        wait(rmutex);</span><br><span class="line">        <span class="comment">/* </span></span><br><span class="line"><span class="comment">        当readcount == 0时,  说明 这个文件可能正在被写进程访问 或者是这个文件在此之前一直处于闲置</span></span><br><span class="line"><span class="comment">        状态且写进程也无意争抢该文件，也有可能 于此同时写进程也想要访问这个文件, 两者将争夺该文件。</span></span><br><span class="line"><span class="comment">        因此必须加上一个wait语句来保证某一个写进程和其它任意进程的互斥。</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        下面分析一下 当readcount == 0时, 这个进程执行wait语句之后可能的结果</span></span><br><span class="line"><span class="comment">        我将结果分为两个大项，四个小项 			</span></span><br><span class="line"><span class="comment">        - 抢到了文件(在抢的一瞬间文件空闲) </span></span><br><span class="line"><span class="comment">        	①文件空闲 且执行wait语句前没有写进程和它抢，它肯定是顺利地得到了文件。</span></span><br><span class="line"><span class="comment">                wmutex值的变化:</span></span><br><span class="line"><span class="comment">                 	wmutex 在wait语句执行前的值为 1 执行之后为 0  </span></span><br><span class="line"><span class="comment">                之后若再有写进程想要访问文件:</span></span><br><span class="line"><span class="comment">                    &lt;1&gt;若在signal(wmutex)语句执行之前 有一个写进程再想通过wait(mutex)来获得文件，</span></span><br><span class="line"><span class="comment">                    那么结果只能是 wmutex 值变为 -1 ，这个写进程被阻塞 进入阻塞队列,等待所有读进程</span></span><br><span class="line"><span class="comment">                    都读完之后，readcount变为0 ,执行signal(wmutex)语句，才会去唤醒这个写进程</span></span><br><span class="line"><span class="comment">                    (在此情况下，这个写进程在阻塞队列中必定处于队头)，</span></span><br><span class="line"><span class="comment">                    顺带着说了 这也是对写进程的不公平之处。</span></span><br><span class="line"><span class="comment">                    &lt;2&gt;若又有一个读进程想要访问文件，请看第50-51行注释</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   	    	②文件空闲 但于此同时有一个写进程也想通过wait语句争抢文件 对文件"上锁"，</span></span><br><span class="line"><span class="comment">       		但是它先于写进程一步抢到了。</span></span><br><span class="line"><span class="comment">        		wmutex值的变化 以及之后再有进程想要访问文件的变化同上述第一条</span></span><br><span class="line"><span class="comment">        - 没有抢到文件(在抢到之前，文件已经被写进程占了)</span></span><br><span class="line"><span class="comment">        	①文件不空闲 有一个写进程一直都在使用着文件。</span></span><br><span class="line"><span class="comment">                wmutex 在wait执行前的值为m，(m &lt;= 0), 执行后为 m-1, </span></span><br><span class="line"><span class="comment">                为什么说wmutex原来值为一个&lt;=0的数呢？</span></span><br><span class="line"><span class="comment">                在这里又要分两种情况,在写进程开始写文件之后，这个读进程想要读文件之前的期间:</span></span><br><span class="line"><span class="comment">                    1. 没有其它进程想要访问文件，那么阻塞队列一定是空的，wmutex 值为0</span></span><br><span class="line"><span class="comment">                    2. 有其它的n个进程曾想要访问文件，结果肯定是它们都进入了阻塞队列，</span></span><br><span class="line"><span class="comment">                    wmutex值为 -n == m </span></span><br><span class="line"><span class="comment">        	②文件空闲 但同时，写进程也想通过wait语句争抢文件 对文件"上锁"，</span></span><br><span class="line"><span class="comment">        	写进程抢先一步，得到了文件。</span></span><br><span class="line"><span class="comment">                wmutex 在wait语句执行之前的值为 0, 之后值为 -1 </span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        	当readcount != 0时, 说明现在有读进程正在读文件，并且第一个执行读操作的进程已经针对</span></span><br><span class="line"><span class="comment">        	写进程上了锁，因此直接令readcount++, 然后进行读操作，读完以后将readcount再减一</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        	以上 其实我已经把整个的思路都给讲了，并且交代了为什么会对写进程不公平</span></span><br><span class="line"><span class="comment">        	还有几种简单情况我没有提的就是 上来就是写进程抢到了文件，在第37行注释中所述情况</span></span><br><span class="line"><span class="comment">        	也是把这个情况给包括了</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        	像进程同步互斥、带pv操作的这种这种联系性很大的代码 </span></span><br><span class="line"><span class="comment">        	真的不能说我要讲就只讲这一段 它们之间紧密联系</span></span><br><span class="line"><span class="comment">        	单独地理解一段代码很难领略到实质，我也是讲着讲着第一段就把整个的都给说出来了hhhh</span></span><br><span class="line"><span class="comment">        	也算是给广大后来者提供一种学习的方式吧 要善于整体感知</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (readcount == <span class="number">0</span>) wait(wmutex);</span><br><span class="line">        readcount++;</span><br><span class="line">        <span class="comment">// "释放" readcount的锁 </span></span><br><span class="line">        signal(rmutex);</span><br><span class="line">        ...</span><br><span class="line">        perform <span class="built_in">read</span> operation;</span><br><span class="line">        ...</span><br><span class="line">        wait(rmutex);</span><br><span class="line">        readcount--;</span><br><span class="line">        <span class="keyword">if</span> (readcount == <span class="number">0</span>) signal(wmutex);</span><br><span class="line">        signal(rmutex);</span><br><span class="line">    &#125;<span class="keyword">while</span>(TRUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写进程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        wait(wmutex);</span><br><span class="line">        perform <span class="built_in">write</span> operation;</span><br><span class="line">        signal(wmutex);</span><br><span class="line">    &#125; <span class="keyword">while</span>(TRUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 程序入口</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cobegin</span><br><span class="line">        Reader();  Writer();</span><br><span class="line">    coend</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="改进版本"><a href="#改进版本" class="headerlink" title="改进版本"></a>改进版本</h2>]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>信号量机制</tag>
        <tag>OS</tag>
        <tag>读者写者问题</tag>
        <tag>记录型信号量</tag>
      </tags>
  </entry>
  <entry>
    <title>RandomDuty(7)</title>
    <url>/2020/09/19/RandomDuty-7/</url>
    <content><![CDATA[<p>有一个兄弟转专业走了T^T, 现在宿舍里有七个人，改进一下代码，取消了文件缓存机制</p>
<a id="more"></a>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 30</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MEMBERONE <span class="meta-string">"曹曾超"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MEMBERTWO <span class="meta-string">"贾金澎"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MEMBERTHREE <span class="meta-string">"安凯晨"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MEMBERFOUR <span class="meta-string">"李艾兴"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MEMBERFIVE <span class="meta-string">"李政尧"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MEMBERSIX <span class="meta-string">"郭艺萌"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MEMBERSEVEN <span class="meta-string">"郝龙祥"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">member</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[MAXN];</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">&#125; Member;</span><br><span class="line"></span><br><span class="line">Member arr[MAX];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> brr[MAX] = &#123;<span class="number">0</span>&#125;, crr[MAX];</span><br><span class="line">    <span class="keyword">int</span> i, j, t, flag, len;</span><br><span class="line">    Member temp;</span><br><span class="line">    <span class="comment">// 拷贝名字</span></span><br><span class="line">    <span class="built_in">strcpy</span>(arr[<span class="number">0</span>].name, MEMBERONE);</span><br><span class="line">    <span class="built_in">strcpy</span>(arr[<span class="number">1</span>].name, MEMBERTWO);</span><br><span class="line">    <span class="built_in">strcpy</span>(arr[<span class="number">2</span>].name, MEMBERTHREE);</span><br><span class="line">    <span class="built_in">strcpy</span>(arr[<span class="number">3</span>].name, MEMBERFOUR);</span><br><span class="line">    <span class="built_in">strcpy</span>(arr[<span class="number">4</span>].name, MEMBERFIVE);</span><br><span class="line">    <span class="built_in">strcpy</span>(arr[<span class="number">5</span>].name, MEMBERSIX);</span><br><span class="line">    <span class="built_in">strcpy</span>(arr[<span class="number">6</span>].name, MEMBERSEVEN);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 核心代码  ↓↓↓↓↓↓↓↓↓↓↓↓</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始产生7个互相不重复的1 - 7内的数字</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 遍历brr数组，得到哪些数还没有生成</span></span><br><span class="line">        <span class="comment">// 把没有生成的数存在数组crr中</span></span><br><span class="line">        len = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(crr, <span class="number">0</span>, <span class="keyword">sizeof</span>(crr));</span><br><span class="line">        <span class="keyword">for</span> (t = <span class="number">0</span>; t &lt; <span class="number">7</span>; t++)</span><br><span class="line">            <span class="keyword">if</span> (brr[t] == <span class="number">0</span>)</span><br><span class="line">                crr[len++] = t + <span class="number">1</span>;</span><br><span class="line">        srand(time(<span class="literal">NULL</span>));</span><br><span class="line">        j = rand() % len;</span><br><span class="line">        arr[i].count = crr[j];</span><br><span class="line">        brr[crr[j] - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">6</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">            <span class="keyword">if</span> (arr[j].count &gt; arr[j + <span class="number">1</span>].count)</span><br><span class="line">            &#123;</span><br><span class="line">                temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 核心代码  ↑↑↑↑↑↑↑↑↑↑↑</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 提升用户体验</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (i)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"周一 "</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"周二 "</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"周三 "</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"周四 "</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"周五 "</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"周六 "</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"周日 "</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, arr[i].name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>日常应用小程序</category>
      </categories>
      <tags>
        <tag>随机值日小程序(7人版，无缓存)</tag>
      </tags>
  </entry>
  <entry>
    <title>RandomDuty</title>
    <url>/2020/09/12/RandomDuty/</url>
    <content><![CDATA[<p>为宿舍内公平值日设计的一个小程序（升级版），点击“阅读全文”查看源码以及使用说明</p>
<a id="more"></a>

<h3 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h3><ol>
<li>编辑代码，根据本宿舍人名更改#define定义的8个成员名。</li>
<li>创建一个<code>.txt</code>文件，在文件中键入数字0 <code>(不要有任何其它字符，例如空格，回车)</code></li>
<li>将代码中 #define定义的FILELOCATION更改为你刚才创建的<code>.txt</code>文件的绝对路径</li>
<li>在C语言IED中运行代码。</li>
</ol>
<h3 id="代码附上"><a href="#代码附上" class="headerlink" title="代码附上"></a>代码附上</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILELOCATION <span class="meta-string">"D:info.txt"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MEMBERONE <span class="meta-string">"曹曾超"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MEMBERTWO <span class="meta-string">"王梓臣"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MEMBERTHREE <span class="meta-string">"贾金澎"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MEMBERFOUR <span class="meta-string">"安凯晨"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MEMBERFIVE <span class="meta-string">"李艾兴"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MEMBERSIX <span class="meta-string">"李政尧"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MEMBERSEVEN <span class="meta-string">"郭艺萌"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MEMBEREIGHT <span class="meta-string">"郝龙祥"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">member</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[MAX];</span><br><span class="line">    <span class="keyword">int</span> cache[MAX];</span><br><span class="line">&#125; Member;</span><br><span class="line"></span><br><span class="line">Member body[MAX];</span><br><span class="line"><span class="keyword">int</span> brr[MAX][MAX];</span><br><span class="line"><span class="keyword">int</span> Brr[MAX][MAX];</span><br><span class="line"><span class="keyword">int</span> crr[MAX];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *fp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> flag, arr[MAX] = &#123;<span class="number">0</span>&#125;, s = <span class="number">0</span>, j, i, temp = <span class="number">1</span>, calculate = <span class="number">1</span>, len = <span class="number">0</span>, x, p, q;</span><br><span class="line">    <span class="built_in">strcpy</span>(body[<span class="number">0</span>].name, MEMBERONE);</span><br><span class="line">    <span class="built_in">strcpy</span>(body[<span class="number">1</span>].name, MEMBERTWO);</span><br><span class="line">    <span class="built_in">strcpy</span>(body[<span class="number">2</span>].name, MEMBERTHREE);</span><br><span class="line">    <span class="built_in">strcpy</span>(body[<span class="number">3</span>].name, MEMBERFOUR);</span><br><span class="line">    <span class="built_in">strcpy</span>(body[<span class="number">4</span>].name, MEMBERFIVE);</span><br><span class="line">    <span class="built_in">strcpy</span>(body[<span class="number">5</span>].name, MEMBERSIX);</span><br><span class="line">    <span class="built_in">strcpy</span>(body[<span class="number">6</span>].name, MEMBERSEVEN);</span><br><span class="line">    <span class="built_in">strcpy</span>(body[<span class="number">7</span>].name, MEMBEREIGHT);</span><br><span class="line">    fp = fopen(FILELOCATION, <span class="string">"r"</span>);</span><br><span class="line">    <span class="built_in">fscanf</span>(fp, <span class="string">"%d"</span>, &amp;flag);</span><br><span class="line">    <span class="comment">// 新轮回的工作</span></span><br><span class="line">    <span class="comment">// 如果flag = 8 或 0，则需要重新开始下一个轮回。</span></span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="number">8</span> || flag == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"旧数据已满一个周期，已清空\n"</span>);</span><br><span class="line">        fclose(fp);</span><br><span class="line">        fp = fopen(FILELOCATION, <span class="string">"w"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">fprintf</span>(fp, <span class="string">"%d\n"</span>, temp);</span><br><span class="line"></span><br><span class="line">        srand(time(<span class="literal">NULL</span>));</span><br><span class="line">        <span class="comment">// 随机，无重复地产生 1 - 8 , 8个数，存储到数组arr中, 并写入缓存的txt文件中</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"新数据为:\n"</span>);</span><br><span class="line">        <span class="keyword">while</span> (s != <span class="number">8</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            temp = <span class="number">1</span>;</span><br><span class="line">            j = rand() % <span class="number">8</span> + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; s; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[i] == j)</span><br><span class="line">                &#123;</span><br><span class="line">                    temp = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (temp)</span><br><span class="line">            &#123;</span><br><span class="line">                arr[s++] = j;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%s %d\n"</span>, body[i].name, j);</span><br><span class="line">                <span class="built_in">fprintf</span>(fp, <span class="string">"%d\n"</span>, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"新数据缓存成功...\n"</span>);</span><br><span class="line">        fclose(fp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// flag是几，就说明当前每行有几个数</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        getc(fp);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"旧数据:\n"</span>);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s"</span>, body[i].name);</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; flag; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">fscanf</span>(fp, <span class="string">"%d"</span>, &amp;body[i].cache[j]);</span><br><span class="line">                brr[i][body[i].cache[j] - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                Brr[i][body[i].cache[j] - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">" %d"</span>, body[i].cache[j]);</span><br><span class="line">                getc(fp);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"正在计算新的值日顺序......\n"</span>);</span><br><span class="line">        i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            len = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">memset</span>(crr, <span class="number">0</span>, <span class="keyword">sizeof</span>(crr));</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (brr[i][j] == <span class="number">0</span>)</span><br><span class="line">                    crr[len++] = j + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// crr数组里现在存的是解的范围,一共有len个数</span></span><br><span class="line">            srand(time(<span class="literal">NULL</span>));</span><br><span class="line">            <span class="comment">// len = 0说明怼出来的数无解，需要回溯</span></span><br><span class="line">            <span class="keyword">if</span>(len == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(p = <span class="number">0</span>; p &lt; <span class="number">8</span>; p++)</span><br><span class="line">                    <span class="keyword">for</span>(q = <span class="number">0</span>; q &lt; <span class="number">8</span>; q++)</span><br><span class="line">                        brr[p][q] = Brr[p][q];</span><br><span class="line">                i = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (len != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                j = rand() % len;</span><br><span class="line">                body[i].cache[flag] = crr[j];</span><br><span class="line">                <span class="keyword">for</span> (x = i + <span class="number">1</span>; x &lt; <span class="number">8</span>; x++)</span><br><span class="line">                    brr[x][crr[j] - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                i++;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">8</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"计算完成!\n"</span>);</span><br><span class="line">        flag++;</span><br><span class="line">        <span class="comment">// 打印结构体数组，测试一下</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"新数据:\n"</span>);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s"</span>, body[i].name);</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; flag; j++)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">" %d"</span>, body[i].cache[j]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"正在将新数据写入缓存文件中...\n"</span>);</span><br><span class="line">        fclose(fp);</span><br><span class="line">        fp = fopen(FILELOCATION, <span class="string">"w"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">fprintf</span>(fp, <span class="string">"%d\n"</span>, flag);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; flag; j++)</span><br><span class="line">                <span class="built_in">fprintf</span>(fp, <span class="string">"%d "</span>, body[i].cache[j]);</span><br><span class="line">            <span class="built_in">fprintf</span>(fp, <span class="string">"\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"写入成功!\n"</span>);</span><br><span class="line">        fclose(fp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>日常应用小程序</category>
      </categories>
      <tags>
        <tag>随机值日小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>problem</title>
    <url>/2020/09/29/problem/</url>
    <content><![CDATA[<p>这个问题困扰我太久了，我还是去研究新算法得了，因为产生的是随机数，我都不知道我的思路还会有多少缺陷，还可能算到无解的情况。</p>
<a id="more"></a>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_NAME 30</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_LOCATION <span class="meta-string">"D:/info.txt"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUMBER1 <span class="meta-string">"a"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUMBER2 <span class="meta-string">"b"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUMBER3 <span class="meta-string">"c"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUMBER4 <span class="meta-string">"d"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUMBER5 <span class="meta-string">"e"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUMBER6 <span class="meta-string">"f"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUMBER7 <span class="meta-string">"g"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUMBER8 <span class="meta-string">"h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">number</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[MAX_NAME];</span><br><span class="line"></span><br><span class="line">&#125; Number;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i, j, lastRounds;</span><br><span class="line"><span class="keyword">int</span> arr[MAX], brr[MAX], crr[MAX], boolx1[MAX];</span><br><span class="line"><span class="keyword">int</span> data[MAX][MAX], boolx2[MAX][MAX], BOOLx2[MAX][MAX];</span><br><span class="line">FILE *fp = <span class="literal">NULL</span>;</span><br><span class="line">Number number[MAX];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 随机生成8个两两不相同的[1,8]范围内的整数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RandomCount</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyStrcpy</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ReadAndPrintData</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Calculate</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintAndWriteData</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Calculate_6</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    MyStrcpy();</span><br><span class="line">    fp = fopen(FILE_LOCATION, <span class="string">"r"</span>);</span><br><span class="line">    <span class="built_in">fscanf</span>(fp, <span class="string">"%d"</span>, &amp;lastRounds);</span><br><span class="line">    <span class="keyword">if</span> (lastRounds == <span class="number">0</span> || lastRounds == <span class="number">8</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fclose(fp);</span><br><span class="line">        fp = fopen(FILE_LOCATION, <span class="string">"w"</span>);</span><br><span class="line">        RandomCount();</span><br><span class="line">        <span class="built_in">fprintf</span>(fp, <span class="string">"%d\n"</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (lastRounds == <span class="number">8</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"旧数据已满，已清空...\n"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"数据为空，需要创建新数据...\n"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"新数据为:\n"</span>);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s   %d\n"</span>, number[i].name, arr[i]);</span><br><span class="line">            <span class="built_in">fprintf</span>(fp, <span class="string">"%d\n"</span>, arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (lastRounds == <span class="number">6</span>)</span><br><span class="line">        Calculate_6();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 文件依然处于开启状态，读取完数据以后方可关闭</span></span><br><span class="line">        getc(fp);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将旧数据读取到data数组中，并打印</span></span><br><span class="line">        ReadAndPrintData(lastRounds);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// √</span></span><br><span class="line">        <span class="comment">// 可以关闭文件了</span></span><br><span class="line">        fclose(fp);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始罪恶的计算</span></span><br><span class="line">        Calculate();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印新数据，并保存到缓存文件中</span></span><br><span class="line">        PrintAndWriteData();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RandomCount</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> number;</span><br><span class="line">    <span class="keyword">int</span> lenC;</span><br><span class="line">    <span class="comment">// arr存放这八个数字</span></span><br><span class="line">    <span class="comment">// brr为布尔类型数组</span></span><br><span class="line">    <span class="comment">// crr为可用的数字</span></span><br><span class="line">    <span class="comment">// arr 和 brr 是需要每次循环都进行缓存的， crr每次循环都要大变样</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 初始化lenC</span></span><br><span class="line">        lenC = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            srand(time(<span class="literal">NULL</span>));</span><br><span class="line">            arr[i] = rand() % <span class="number">8</span> + <span class="number">1</span>;</span><br><span class="line">            brr[arr[i] - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历布尔数组，从而确定没有使用的数字，存到crr数组里</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++)</span><br><span class="line">            <span class="keyword">if</span> (brr[j] == <span class="number">0</span>)</span><br><span class="line">                crr[lenC++] = j;</span><br><span class="line">        <span class="comment">// crr数组的长度为lenC，即crr里有lenC个数</span></span><br><span class="line">        srand(time(<span class="literal">NULL</span>));</span><br><span class="line">        number = crr[rand() % lenC];</span><br><span class="line">        arr[i] = number + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 把number存进arr数组以后，记得在布尔数组里把对应的位置的数置为1</span></span><br><span class="line">        brr[number] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyStrcpy</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">strcpy</span>(number[<span class="number">0</span>].name, NUMBER1);</span><br><span class="line">    <span class="built_in">strcpy</span>(number[<span class="number">1</span>].name, NUMBER2);</span><br><span class="line">    <span class="built_in">strcpy</span>(number[<span class="number">2</span>].name, NUMBER3);</span><br><span class="line">    <span class="built_in">strcpy</span>(number[<span class="number">3</span>].name, NUMBER4);</span><br><span class="line">    <span class="built_in">strcpy</span>(number[<span class="number">4</span>].name, NUMBER5);</span><br><span class="line">    <span class="built_in">strcpy</span>(number[<span class="number">5</span>].name, NUMBER6);</span><br><span class="line">    <span class="built_in">strcpy</span>(number[<span class="number">6</span>].name, NUMBER7);</span><br><span class="line">    <span class="built_in">strcpy</span>(number[<span class="number">7</span>].name, NUMBER8);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ReadAndPrintData</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"旧数据为:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s  "</span>, number[i].name);</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; lastRounds; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fscanf</span>(fp, <span class="string">"%d "</span>, &amp;data[i][j]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>, data[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 吸收文件内的换行，或者最后一行的EOF</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Calculate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lenC, counts, number, huisu = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// boolx2 二维布尔数组，哪个元素为一，那么该元素的下标加 1 这个数，已经产生过了</span></span><br><span class="line">    <span class="comment">// 本次计算需要的数据有，data二维数组里的内容</span></span><br><span class="line">    <span class="comment">// bool二维数组用来计每次横向已经占有的数据</span></span><br><span class="line">    <span class="comment">// 一维布尔数组用来计纵向产生的数据</span></span><br><span class="line">    <span class="comment">// 遍历二维布尔数组的对应行，和一维布尔数组，若都为0，则该数是解，将其放到crr数组里</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; lastRounds; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            boolx2[i][data[i][j] - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// BOOLx2备份数据，用于回溯</span></span><br><span class="line">            BOOLx2[i][data[i][j] - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span> (counts = <span class="number">0</span>; counts &lt; <span class="number">8</span>; counts++)</span><br><span class="line">    &#123;</span><br><span class="line">        lenC = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(crr, <span class="number">0</span>, <span class="keyword">sizeof</span>(crr));</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!boolx2[counts][j])</span><br><span class="line">            &#123;</span><br><span class="line">                crr[lenC++] = j + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// crr数组里存的是第 counts 行，横纵都未出现过的数</span></span><br><span class="line">        srand(time(<span class="literal">NULL</span>));</span><br><span class="line">        <span class="keyword">if</span> (lenC)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// lenC != 0 ，往下算就好</span></span><br><span class="line">            number = rand() % lenC;</span><br><span class="line">            data[counts][lastRounds] = crr[number];</span><br><span class="line">            <span class="comment">// 存完crr[number]以后，还需要把二维布尔数组中当前行以下的每一列中</span></span><br><span class="line">            <span class="comment">// 下标为 crr[number] - 1的元素置为 1</span></span><br><span class="line">            <span class="keyword">for</span> (i = counts + <span class="number">1</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">                boolx2[i][crr[number] - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"回溯次数 %d次\n"</span>, huisu++);</span><br><span class="line">            <span class="comment">// lenC == 0 , 运气不好，怼到无解的情况了， 需要回溯呀，从头开始算吧， 哎！</span></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">                <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; lastRounds; j++)</span><br><span class="line">                    boolx2[i][j] = BOOLx2[i][j];</span><br><span class="line">            counts = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    lastRounds++;</span><br><span class="line">    <span class="comment">// 可能会出现无解的情况，因此，记得回溯！！</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintAndWriteData</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fp = fopen(FILE_LOCATION, <span class="string">"w"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"新数据为:\n"</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(fp, <span class="string">"%d\n"</span>, lastRounds);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s  "</span>, number[i].name);</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; lastRounds; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(fp, <span class="string">"%d "</span>, data[i][j]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>, data[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">fprintf</span>(fp, <span class="string">"\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Calculate_6</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> crr[MAX * <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>, temp, t;</span><br><span class="line">    <span class="comment">// 把数据录到布尔数组里，然后确定解</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; lastRounds; j++)</span><br><span class="line">            boolx2[i][data[i][j] - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; lastRounds; j++)</span><br><span class="line">            <span class="keyword">if</span> (boolx2[i][data[i][j] - <span class="number">1</span>] == <span class="number">0</span>)</span><br><span class="line">                crr[len++] = data[i][j];</span><br><span class="line">    <span class="comment">// crr数组长度最后一定是16， 下标从 0 - 15</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        srand(time(<span class="literal">NULL</span>));</span><br><span class="line">        <span class="comment">// 第一次，先从第一个和第二个元素中选择一个</span></span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            j = rand() % <span class="number">2</span>;</span><br><span class="line">            data[<span class="number">0</span>][lastRounds] = crr[j];</span><br><span class="line">            temp = crr[j];</span><br><span class="line">            crr[j] = <span class="number">0</span>;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(t = <span class="number">0</span>; t &lt; len; t++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp == crr[t])</span><br><span class="line">            &#123;</span><br><span class="line">                crr[t] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (t % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    temp = crr[t + <span class="number">1</span>];</span><br><span class="line">                    data[t / <span class="number">2</span> + <span class="number">1</span>][lastRounds] =  crr[t + <span class="number">1</span>];</span><br><span class="line">                    crr[t + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    temp = crr[t - <span class="number">1</span>];</span><br><span class="line">                    data[t / <span class="number">2</span> + <span class="number">1</span>][lastRounds] =  crr[t - <span class="number">1</span>];</span><br><span class="line">                    crr[t - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">4 5 6 7 2 3 </span><br><span class="line">2 7 3 6 4 8 </span><br><span class="line">6 4 2 5 3 7 </span><br><span class="line">5 6 8 3 1 4 </span><br><span class="line">8 2 7 1 6 5 </span><br><span class="line">1 3 5 8 2 6 </span><br><span class="line">7 1 4 2 8 3 </span><br><span class="line">3 8 1 4 5 2</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>矩阵运算问题</category>
      </categories>
      <tags>
        <tag>问题问题问题</tag>
      </tags>
  </entry>
  <entry>
    <title>reverse the linkList</title>
    <url>/2020/09/23/reverse-the-linkList/</url>
    <content><![CDATA[<center>链表的头插和逆置操作，很有技巧性，很值得思考</center>

<a id="more"></a>


<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">MyStruct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">MyStruct</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;Node, *pList;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Reverse</span><span class="params">(pList *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(pList)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ReverseOrder</span><span class="params">(pList*)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	</span><br><span class="line">	pList pHead = <span class="literal">NULL</span>;</span><br><span class="line">	Reverse(&amp;pHead);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"对空链表头插5个结点:\n"</span>);</span><br><span class="line">	Print(pHead);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"头插完之后，将链表元素转置:\n"</span>);</span><br><span class="line">	ReverseOrder(&amp;pHead);</span><br><span class="line">	Print(pHead);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Reverse</span><span class="params">(pList * ppHead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	pList pNewNode;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		pNewNode = (pList) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">		pNewNode-&gt;data = i;</span><br><span class="line">		pNewNode -&gt;next = *ppHead;</span><br><span class="line">		*ppHead = pNewNode;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(pList phead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	pList temp = phead;</span><br><span class="line">	<span class="keyword">while</span>(temp != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, temp-&gt;data);</span><br><span class="line">		temp = temp -&gt; next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ReverseOrder</span><span class="params">(pList* pphead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	pList p = *pphead, q = (*pphead) -&gt;next;</span><br><span class="line">	*pphead = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">while</span>(q != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		p -&gt; next = *pphead;</span><br><span class="line">		*pphead = p;</span><br><span class="line">		p = q;</span><br><span class="line">		q = q-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	p-&gt;next = *pphead;</span><br><span class="line">	*pphead = p;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>DSandAL</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>AL</tag>
        <tag>算法</tag>
        <tag>DS</tag>
        <tag>链表头插</tag>
        <tag>链表逆置</tag>
      </tags>
  </entry>
  <entry>
    <title>二分搜索</title>
    <url>/2020/12/22/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/</url>
    <content><![CDATA[<center>二分搜索，写的时候和快排做了一波对比，还是有一些收获的</center>

<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 二分搜索</span></span><br><span class="line"><span class="comment">// 二分搜索不同于快排中的二分递归，</span></span><br><span class="line"><span class="comment">// 二分搜索路径只有一条，只要找到头就可以了</span></span><br><span class="line"><span class="comment">// 而快排中的二分需要全覆盖(因为是要对整个数组进行排序)</span></span><br><span class="line"><span class="comment">// 这也是为什么二分搜索不使用递归也可以很轻松地实现</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归写法和非递归写法</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LENGTH 10</span></span><br><span class="line"><span class="comment">// 查找目标</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TARGET 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归写法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch1</span><span class="params">(<span class="keyword">int</span> *, <span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="comment">// 循环写法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch2</span><span class="params">(<span class="keyword">int</span> *, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 初始化待查找的数组</span></span><br><span class="line">	<span class="comment">// 数组的0号空间不使用</span></span><br><span class="line">	<span class="keyword">int</span> arr[<span class="number">11</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> index = binarySearch1(arr, <span class="number">1</span>, LENGTH, TARGET);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"递归写法得到的%d的下标: %d\n"</span>, TARGET, index);</span><br><span class="line">	index = binarySearch2(arr, TARGET);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"循环写法得到的%d的下标: %d\n"</span>, TARGET, index);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归写法</span></span><br><span class="line"><span class="comment">// 参数为数组首地址，每次二分的起始位置和终止位置， 查找值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch1</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> <span class="built_in">begin</span>, <span class="keyword">int</span> <span class="built_in">end</span>, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">begin</span> &gt; <span class="built_in">end</span>) </span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="comment">// 中间界值的下标</span></span><br><span class="line">	<span class="keyword">int</span> middleIndex = (<span class="built_in">begin</span> + <span class="built_in">end</span>) / <span class="number">2</span>;</span><br><span class="line">	<span class="comment">// 中间界值</span></span><br><span class="line">	<span class="keyword">int</span> middleValue = arr[middleIndex];</span><br><span class="line">	<span class="keyword">if</span> (target &gt; middleValue)  <span class="comment">// 在界值右边</span></span><br><span class="line">		binarySearch1(arr, middleIndex + <span class="number">1</span>, <span class="built_in">end</span>, target);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(target &lt; middleValue) <span class="comment">// 在界值左边</span></span><br><span class="line">		binarySearch1(arr, <span class="built_in">begin</span>, middleIndex - <span class="number">1</span>, target);</span><br><span class="line">	<span class="keyword">else</span> <span class="comment">// 等于界值，直接返回界值的下标</span></span><br><span class="line">		<span class="keyword">return</span> middleIndex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环写法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch2</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 开始下标和结束下标</span></span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">begin</span> = <span class="number">1</span>, <span class="built_in">end</span> = LENGTH;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">begin</span> &lt; <span class="built_in">end</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 中间位置下标</span></span><br><span class="line">		<span class="keyword">int</span> middleIndex = (<span class="built_in">begin</span> + <span class="built_in">end</span>) / <span class="number">2</span>;</span><br><span class="line">		<span class="comment">// 中间值</span></span><br><span class="line">		<span class="keyword">int</span> middleValue = arr[middleIndex];</span><br><span class="line">		<span class="keyword">if</span> (target &gt; middleValue)</span><br><span class="line">			<span class="built_in">begin</span> = middleIndex + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(target &lt; middleValue)</span><br><span class="line">			<span class="built_in">end</span> = middleIndex - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">			<span class="keyword">return</span> middleIndex;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>二分搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树</title>
    <url>/2020/11/07/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<center>主要记录个人认为比较重要或是易错的知识</center>

<a id="more"></a>

<h3 id="二叉树和树-区分"><a href="#二叉树和树-区分" class="headerlink" title="二叉树和树 区分"></a>二叉树和树 区分</h3><p><strong>二叉树不是树</strong>， 因为相比于树，它多了两个条件，</p>
<ol>
<li>每个结点的度最多是2 (此属性并不能否定它是一个树，因为可以认为是树的一种特殊形式)。 </li>
<li>每个结点的孩子(若有孩子)有左右之分，这个条件直接否定了它是一个树，因为树的孩子可以没有左右之分。</li>
</ol>
<h3 id="二叉树的性质三"><a href="#二叉树的性质三" class="headerlink" title="二叉树的性质三"></a>二叉树的性质三</h3><p><code>对任何一棵二叉树 T，如果其叶子数为 n_0，度为 2 的结点数为 n_2，则 n_0 = n_2 + 1。</code> </p>
<blockquote>
<p>证明: </p>
<p>n = n_0 + n_1 + n_2</p>
<p>n = 2 * n_2 + n_1 + 1</p>
<p>综上可得， n_0 = n_2 + 1</p>
</blockquote>
<h3 id="二叉链表"><a href="#二叉链表" class="headerlink" title="二叉链表"></a>二叉链表</h3><ul>
<li><p>结点结构：每一个结点有两个指针域分别负责指向左孩子和右孩子，一个数据域用于存储</p>
<h4 id="在-n-个结点的二叉链表中有-n-1-个空指针域"><a href="#在-n-个结点的二叉链表中有-n-1-个空指针域" class="headerlink" title="在 n 个结点的二叉链表中有 n + 1 个空指针域"></a>在 <em>n</em> 个结点的二叉链表中有 <em>n</em> + 1 个空指针域</h4><blockquote>
<p>证明：</p>
<p>在二叉链表中，一个指针的指向就代表二叉树中的一个树杈，因为一共有n个结点，出了根结点以外，其它的结点都有一个树杈和它相连，因此二叉树中有 n - 1个树杈，即 n - 1 个非空指针域</p>
<p>空指针域 = 总指针域 - 非空指针域</p>
<p>​                     =  结点数 * 2 -  树杈</p>
<p>​                     = n * 2 - (n - 1)</p>
<p>​                     = n + 1</p>
</blockquote>
</li>
</ul>
<h3 id="三叉链表"><a href="#三叉链表" class="headerlink" title="三叉链表"></a>三叉链表</h3><ul>
<li>结点结构：在二叉链表的基础上多了一个指向双亲的指针域</li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>内部类</title>
    <url>/2021/04/03/%E5%86%85%E9%83%A8%E7%B1%BB/</url>
    <content><![CDATA[<center>对内部类，主要是匿名内部类的一波复习以及对其浅层原理的思考</center>

<a id="more"></a>

<h2 id="写在最前"><a href="#写在最前" class="headerlink" title="写在最前"></a>写在最前</h2><p>学安卓的时候匿名内部类忘光了，写这篇文章主要是为了复习一波匿名内部类，看了一会匿名内部类，发现很多内部类的东西也是忘的差不多了，毕竟这些东西是一个有机的整体（好像也不太恰当哈   匿名内部类是内部类的一部分），单单复习匿名内部类收获不大，也领略不到一些原理实质性、互相之间对比的内容，鉴于前面所说， 我还是把内部类从头复习了一遍</p>
<h2 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h2><p>作为外部类的一个成员存在，与类的属性，方法并列</p>
<p>成员内部类中不能定义静态成员</p>
<h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel7</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Contents <span class="title">contents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Contents() &#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">11</span>;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Parcel7 p = <span class="keyword">new</span> Parcel7();</span><br><span class="line">        Contents c = p.contents();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>实质：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel7b</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyContents</span> <span class="keyword">implements</span> <span class="title">Contents</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">11</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Contents <span class="title">contents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> MyContents();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Parcel7b p = <span class="keyword">new</span> Parcel7b();</span><br><span class="line">        Contents c = p.contents();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>在第二张图中，MyContents就是那个第一张代码图片中没有出现的匿名类</p>
<p>原理：创建一个继承自Contents的匿名类的对象，通过new表达式返回的引用被自动向上 转型为对Contents的引用</p>
<p>在这里 Contents是外部已写好的一个接口，  <code>new Contents() { .... }</code> 看似是要给一个接口实例化对象要报错，其实不然，这并不是给一个接口实例化对象，而是给继承了这个接口的一个内部类实例化一次对象，所以返回值是实现了Contents接口的一个匿名类的一个对象，该匿名类只会有一个对象，就是在定义的时候，顺便new一个出来。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JavaBase</tag>
        <tag>Java基础</tag>
        <tag>Java</tag>
        <tag>内部类</tag>
      </tags>
  </entry>
  <entry>
    <title>依据广度优先的输入字符串 生成二叉树</title>
    <url>/2020/12/26/%E4%BE%9D%E6%8D%AE%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E7%9A%84%E8%BE%93%E5%85%A5%E5%AD%97%E7%AC%A6%E4%B8%B2-%E7%94%9F%E6%88%90%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<center>根据广度优先输入的字符串 生成一颗二叉树</center>

<a id="more"></a>

<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这个根据输入的字符串自动生成一个二叉树</span><br><span class="line">使用的思想是广搜(BFS)</span><br><span class="line">要用到队列生成二叉树</span><br><span class="line"></span><br><span class="line">举个例子</span><br><span class="line">输入  12634^7^^^58^^^^^</span><br><span class="line">生成的二叉树为：</span><br><span class="line"></span><br><span class="line">                       1</span><br><span class="line">              &#x2F;                \</span><br><span class="line">             2                  6</span><br><span class="line">          &#x2F;    \              &#x2F;   \</span><br><span class="line">         3      4            ^     7</span><br><span class="line">       &#x2F;   \  &#x2F;   \               &#x2F;  \</span><br><span class="line">      ^    ^  ^    5             8    ^</span><br><span class="line">                  &#x2F; \           &#x2F; \</span><br><span class="line">                 ^   ^         ^   ^</span><br><span class="line"></span><br><span class="line">    你可能会疑惑这个二叉树和平时的不一样，</span><br><span class="line">    其实这才是计算机眼中的二叉树，</span><br><span class="line">    只是平时见到的把NULL省略掉了</span><br><span class="line">    既然我们是学代码的，我们的脑回路就应该和计算机一样</span><br><span class="line">    难道不是么? （手动滑稽）</span><br></pre></td></tr></table></figure>

<h2 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h2><p>写这个算法的时候，get到一个新的点就是：</p>
<p>我可以传结构体变量中的成员变量的地址给函数，而不是直接传一个结构体地址</p>
<p>这样的话，可以具体到结构体中的某个域来进行修改</p>
<p>比如说 左右子树，当你这个函数希望有的时候修改的是存左子树地址的指针域，有的时候修改存右子树地址的指针域时，如果你直接传一个结构体地址过去，除非有标志位或者标志变量，否则是不知道该做什么操作的，这时候你只需要在调用的时候，直接传节点中存左子树地址的指针的地址或者传节点中存右子树地址的指针的地址就行，而不用再去设置标志判断了。</p>
<p>详情请见本代码中为一个节点的左右指针域赋值的操作</p>
<h2 id="代码附上"><a href="#代码附上" class="headerlink" title="代码附上"></a>代码附上</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">treeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">char</span> data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">treeNode</span> *<span class="title">left</span>, *<span class="title">right</span>;</span></span><br><span class="line">&#125; TreeNode, *Tree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">queue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	Tree arr[MAXSIZE];</span><br><span class="line">	<span class="keyword">int</span> tail;</span><br><span class="line">	<span class="keyword">int</span> head;</span><br><span class="line">&#125; * Queue;</span><br><span class="line"></span><br><span class="line"><span class="function">Queue <span class="title">newQueue</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 入队的元素是节点的地址</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inQueue</span><span class="params">(Queue, Tree)</span></span>;</span><br><span class="line"><span class="comment">// 出队的是节点的地址</span></span><br><span class="line"><span class="function">Tree <span class="title">outQueue</span><span class="params">(Queue)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">getStr</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">Tree <span class="title">creTree</span><span class="params">(<span class="keyword">char</span> *, Queue)</span></span>;</span><br><span class="line"><span class="comment">// 传一个队列，树节点的二级指针， 字符串，当前字符的索引位置</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">creTree2</span><span class="params">(Tree *, Queue, <span class="keyword">char</span> *, <span class="keyword">int</span> *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Tree)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 得到了一个空队列的地址</span></span><br><span class="line">	Queue <span class="built_in">queue</span> = newQueue();</span><br><span class="line">	<span class="comment">// 得到用户输入的字符串</span></span><br><span class="line">	<span class="keyword">char</span> *str = getStr();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, str);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="built_in">strlen</span>(str));</span><br><span class="line">	<span class="comment">// 根据用户输入的字符串生成二叉树</span></span><br><span class="line">	Tree tree = creTree(str, <span class="built_in">queue</span>);</span><br><span class="line">	preOrder(tree);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Tree tree)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (tree == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%c\n"</span>, tree-&gt;data);</span><br><span class="line">	preOrder(tree-&gt;left);</span><br><span class="line">	preOrder(tree-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">creTree2</span><span class="params">(Tree *ppChild, Queue <span class="built_in">queue</span>, <span class="keyword">char</span> *str, <span class="keyword">int</span> *strIndex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (*strIndex &lt; <span class="built_in">strlen</span>(str))</span><br><span class="line">	&#123;</span><br><span class="line">		Tree p;</span><br><span class="line">		<span class="keyword">if</span> (str[*strIndex] == <span class="string">'^'</span>)</span><br><span class="line">			p = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			p = (Tree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TreeNode));</span><br><span class="line">			p-&gt;data = str[*strIndex];</span><br><span class="line">			inQueue(<span class="built_in">queue</span>, p);</span><br><span class="line">		&#125;</span><br><span class="line">		(*strIndex)++;</span><br><span class="line">		*ppChild = p;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Tree <span class="title">creTree</span><span class="params">(<span class="keyword">char</span> *str, Queue <span class="built_in">queue</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> nodeCounts = <span class="built_in">strlen</span>(str);</span><br><span class="line">	<span class="keyword">int</span> strIndex = <span class="number">0</span>;</span><br><span class="line">	Tree p = (Tree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TreeNode));</span><br><span class="line">	p-&gt;data = str[strIndex];</span><br><span class="line">	strIndex++;</span><br><span class="line">	inQueue(<span class="built_in">queue</span>, p);</span><br><span class="line">	<span class="comment">// 头指针</span></span><br><span class="line">	Tree tree = p;</span><br><span class="line">	<span class="keyword">while</span> (strIndex &lt; nodeCounts)</span><br><span class="line">	&#123;</span><br><span class="line">		Tree temp = outQueue(<span class="built_in">queue</span>);</span><br><span class="line">		<span class="comment">// 队列的地址， 当前下标， 字符数组</span></span><br><span class="line">		<span class="comment">// 树节点的二级指针</span></span><br><span class="line">		creTree2(&amp;(temp-&gt;left), <span class="built_in">queue</span>, str, &amp;strIndex);</span><br><span class="line">		creTree2(&amp;(temp-&gt;right), <span class="built_in">queue</span>, str, &amp;strIndex);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 接收用户输入的一串字符</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">getStr</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> *p = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * MAXSIZE);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%s"</span>, p);</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建并初始化一个队列出来</span></span><br><span class="line"><span class="function">Queue <span class="title">newQueue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Queue <span class="built_in">list</span> = (Queue)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct <span class="built_in">queue</span>));</span><br><span class="line">	<span class="built_in">list</span>-&gt;head = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">list</span>-&gt;tail = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 循环入队</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inQueue</span><span class="params">(Queue <span class="built_in">queue</span>, Tree p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> ((<span class="built_in">queue</span>-&gt;tail + <span class="number">1</span>) % MAXSIZE == <span class="built_in">queue</span>-&gt;head)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"队满, 入队失败\n"</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">queue</span>-&gt;arr[<span class="built_in">queue</span>-&gt;tail] = p;</span><br><span class="line">	<span class="built_in">queue</span>-&gt;tail = (<span class="built_in">queue</span>-&gt;tail + <span class="number">1</span>) % MAXSIZE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 循环出队</span></span><br><span class="line"><span class="function">Tree <span class="title">outQueue</span><span class="params">(Queue <span class="built_in">queue</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">queue</span>-&gt;tail == <span class="built_in">queue</span>-&gt;head)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"队空, 出队失败\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Tree temp = <span class="built_in">queue</span>-&gt;arr[<span class="built_in">queue</span>-&gt;head];</span><br><span class="line">	<span class="built_in">queue</span>-&gt;head = (<span class="built_in">queue</span>-&gt;head + <span class="number">1</span>) % MAXSIZE;</span><br><span class="line">	<span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>动态数组操作</title>
    <url>/2020/10/02/%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>​     动态数组操作均封装成函数，涉及到的操作有：</p>
<ol>
<li>动态数组初始化</li>
<li>打印</li>
<li>添加元素</li>
<li>删除元素</li>
</ol>
<a id="more"></a>

<p>代码附上</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 动态数组</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> InitialSize 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EachIncreaseSize 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BatchAddNumber 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DynamicArray</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> *<span class="built_in">array</span>;</span><br><span class="line">    <span class="keyword">int</span> arrayLenth;</span><br><span class="line">    <span class="keyword">int</span> initialSize;</span><br><span class="line">&#125; DynamicArray;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化动态数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitialList</span><span class="params">(DynamicArray *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过手动输入给数组批量、顺序添加元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddElement</span><span class="params">(DynamicArray *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintArray</span><span class="params">(DynamicArray)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动给数组批量、顺序添加元素</span></span><br><span class="line"><span class="comment">// 自动添加多少请改变 宏定义BatchAddNumer 的值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BatchAdd</span><span class="params">(DynamicArray *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertElement</span><span class="params">(DynamicArray *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeletElement</span><span class="params">(DynamicArray *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DynamicArray <span class="built_in">list</span>;</span><br><span class="line">    InitialList(&amp;<span class="built_in">list</span>);</span><br><span class="line">    <span class="comment">//  AddElement(&amp;list);</span></span><br><span class="line">    BatchAdd(&amp;<span class="built_in">list</span>);</span><br><span class="line">    PrintArray(<span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line">    InsertElement(&amp;<span class="built_in">list</span>);</span><br><span class="line">    PrintArray(<span class="built_in">list</span>);</span><br><span class="line">    DeletElement(&amp;<span class="built_in">list</span>);</span><br><span class="line">    PrintArray(<span class="built_in">list</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"==========================\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitialList</span><span class="params">(DynamicArray *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 在堆区申请100个int类型长度的内存</span></span><br><span class="line">    <span class="comment">// 将这块内存的首地址存入结构体中的arry指针</span></span><br><span class="line">    p-&gt;<span class="built_in">array</span> = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(InitialSize * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="comment">// 数组长度为0</span></span><br><span class="line">    p-&gt;arrayLenth = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 数组初始化时，可存放的int数据长度为100</span></span><br><span class="line">    p-&gt;initialSize = InitialSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddElement</span><span class="params">(DynamicArray *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, n;</span><br><span class="line">    j = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入要添加元素的数量 \n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (i = p-&gt;arrayLenth; i &lt; p-&gt;arrayLenth + n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"请输入第%d个要添加的元素: "</span>, ++j);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, (p-&gt;<span class="built_in">array</span>) + i);</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;arrayLenth += n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintArray</span><span class="params">(DynamicArray <span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    Print();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"当前数组信息:\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"当前数组长度为 %d \n"</span>, <span class="built_in">list</span>.arrayLenth);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"当前数组容量为 %d \n"</span>, <span class="built_in">list</span>.initialSize);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"打印数组\n"</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">list</span>.arrayLenth; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, (<span class="built_in">list</span>.<span class="built_in">array</span>)[i]);</span><br><span class="line">   	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    Print();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BatchAdd</span><span class="params">(DynamicArray *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, j = p-&gt;arrayLenth; i &lt; BatchAddNumber; i++)</span><br><span class="line">        (p-&gt;<span class="built_in">array</span>)[j++] = i + <span class="number">1</span>;</span><br><span class="line">    p-&gt;arrayLenth += BatchAddNumber;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertElement</span><span class="params">(DynamicArray *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, n;</span><br><span class="line">    <span class="keyword">int</span> *x = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> *y = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> *temp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入要插入到第几位\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;i);</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">1</span> || i &gt; (p-&gt;arrayLenth + <span class="number">1</span>))</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;arrayLenth &gt;= p-&gt;initialSize)</span><br><span class="line">        temp = (<span class="keyword">int</span>*)<span class="built_in">realloc</span>(p-&gt;<span class="built_in">array</span>, (InitialSize + EachIncreaseSize) * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">if</span>(temp == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    <span class="comment">// if temp != NULL &amp;&amp; temp != p, 说明realloc函数没有在原来开辟的后面加空间</span></span><br><span class="line">    <span class="comment">// 而是又开辟了一块大内存，因此原来开辟的内存应该被释放掉</span></span><br><span class="line">    p-&gt;initialSize += EachIncreaseSize;</span><br><span class="line">    <span class="keyword">if</span>(temp != p-&gt;<span class="built_in">array</span>)</span><br><span class="line">        <span class="built_in">free</span>(p-&gt;<span class="built_in">array</span>);</span><br><span class="line">    p-&gt;<span class="built_in">array</span> = temp;</span><br><span class="line">    x = (p-&gt;<span class="built_in">array</span>) + i - <span class="number">1</span>;</span><br><span class="line">    y = (p-&gt;<span class="built_in">array</span>) + p-&gt;arrayLenth - <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"要插入元素的值是多少\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">while</span>(y &gt;= x)</span><br><span class="line">    &#123;</span><br><span class="line">        *(y + <span class="number">1</span>) = *y;</span><br><span class="line">        y--;</span><br><span class="line">    &#125;</span><br><span class="line">    *x = n;</span><br><span class="line">    p-&gt;arrayLenth++;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeletElement</span><span class="params">(DynamicArray * plist)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> &amp;arryLenth = plist-&gt;arrayLenth;</span><br><span class="line">    <span class="keyword">int</span> * arry = plist-&gt;<span class="built_in">array</span>;</span><br><span class="line">    <span class="keyword">int</span> *p = <span class="literal">NULL</span>, *q = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入要删除第几个元素\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;i);</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">1</span> || i &gt; arryLenth)</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    p = arry + i - <span class="number">1</span>;</span><br><span class="line">    q = arry + arryLenth - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(p &lt;= q)</span><br><span class="line">    &#123;</span><br><span class="line">        *p = *(p + <span class="number">1</span>);</span><br><span class="line">        p++;</span><br><span class="line">    &#125;</span><br><span class="line">    arryLenth--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>动态数组</tag>
      </tags>
  </entry>
  <entry>
    <title>博客本地迁移</title>
    <url>/2021/03/17/%E5%8D%9A%E5%AE%A2%E6%9C%AC%E5%9C%B0%E8%BF%81%E7%A7%BB/</url>
    <content><![CDATA[<center>早就想给自己博客换个盘了 却一直找不到办法  原来如此简单hhh</center>

<a id="more"></a>

<ol>
<li>新建一个文件夹</li>
<li>把原来的文件粘贴进来</li>
<li>hexo init</li>
<li>git init</li>
<li>hexo s  测试一下4000端口</li>
</ol>
]]></content>
      <categories>
        <category>博客迁移</category>
      </categories>
      <tags>
        <tag>博客迁移</tag>
      </tags>
  </entry>
  <entry>
    <title>双向链表基本操作</title>
    <url>/2020/10/12/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;双向链表的基本操作</p>
<ol>
<li>初始化一个空的双向链表</li>
<li>尾插添加结点</li>
<li>顺序随机掉头逆序打印双向链表</li>
<li>按序号添加结点</li>
<li>按序号删除结点 </li>
</ol>
<a id="more"></a>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 双向链表</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">linkList</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">linkList</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">linkList</span> *<span class="title">prior</span>;</span></span><br><span class="line">&#125; node, *<span class="built_in">list</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化一个空的双向链表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitList</span><span class="params">(<span class="built_in">list</span> *ppHead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">list</span> p = (<span class="built_in">list</span>)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(node));</span><br><span class="line">    *ppHead = p;</span><br><span class="line">    p-&gt;data = <span class="number">0</span>;</span><br><span class="line">    p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向双向链表中批量添加5个值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddNode</span><span class="params">(<span class="built_in">list</span> pHead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">list</span> temp = pHead;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">list</span> p = (<span class="built_in">list</span>)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(node));</span><br><span class="line">        temp-&gt;next = p;</span><br><span class="line">        p-&gt;data = i + <span class="number">1</span>;</span><br><span class="line">        p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        p-&gt;prior = temp;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印双向链表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintList</span><span class="params">(<span class="built_in">list</span> pFirstNode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 先打印双向链表</span></span><br><span class="line">    <span class="built_in">list</span> temp = pFirstNode;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"显示双向链表信息:\n"</span>);</span><br><span class="line">    <span class="keyword">while</span> (temp != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, temp-&gt;data);</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 顺序然后逆序打印双向链表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OrderAndReverseOrderPrint</span><span class="params">(<span class="built_in">list</span> pHead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">list</span> temp = pHead;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"利用双链表的特性实现先顺序打印然后逆序打印\n"</span>);</span><br><span class="line">    <span class="keyword">while</span> (temp-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, temp-&gt;next-&gt;data);</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 现在temp的值为最后一个结点的地址,然后顺着打印即可</span></span><br><span class="line">    <span class="keyword">while</span> (temp != pHead)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, temp-&gt;data);</span><br><span class="line">        temp = temp-&gt;prior;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按序号添加一个结点，i为序号，data为数据</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddBySerial</span><span class="params">(<span class="built_in">list</span> pHead, <span class="keyword">int</span> i, <span class="keyword">int</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 添加结点，要添加的结点的前一个结点的范围是</span></span><br><span class="line">    <span class="comment">// 0结点(头结点)一直到最后的NULL结点</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"在第 %d 个结点处插入数据为 %d 的结点\n"</span>, i, data);</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">list</span> temp = pHead;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; i - <span class="number">1</span> &amp;&amp; temp != <span class="literal">NULL</span>; j++)</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (temp == <span class="literal">NULL</span> || j &gt; i - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"传入的序号 %d 不在允许插入的范围内"</span>, i);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果是要尾插，那么还需要特殊拿出来考虑，因为尾结点的后面没有结点了</span></span><br><span class="line">    <span class="built_in">list</span> p = (<span class="built_in">list</span>)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(node));</span><br><span class="line">    p-&gt;data = data;</span><br><span class="line">    <span class="keyword">if</span> (temp-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        p-&gt;prior = temp;</span><br><span class="line">        temp-&gt;next = p;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;next = temp-&gt;next;</span><br><span class="line">    temp-&gt;next-&gt;prior = p;</span><br><span class="line">    p-&gt;prior = temp;</span><br><span class="line">    temp-&gt;next = p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按照序号删除一个结点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteSerial</span><span class="params">(<span class="built_in">list</span> pHead, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// temp 现在指向第一个结点</span></span><br><span class="line">    <span class="built_in">list</span> temp = pHead-&gt;next;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"删除序号为 %d 的结点\n"</span>, i);</span><br><span class="line">    <span class="comment">// 不同于单链表的删除，双向链表在删除结点时，直接找到要删除结点的</span></span><br><span class="line">    <span class="comment">// 地址即可，单链表需要找到被删除结点的前一个结点的地址</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; i &amp;&amp; temp != <span class="literal">NULL</span>; j++)</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (j &gt; i || temp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"找不到要删除的序号为 %d 结点\n"</span>, i);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 要删除的是尾结点</span></span><br><span class="line">    <span class="keyword">if</span> (temp-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">        temp-&gt;prior-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        temp-&gt;prior-&gt;next = temp-&gt;next;</span><br><span class="line">        temp-&gt;next-&gt;prior = temp-&gt;prior;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(temp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d 号结点删除成功!\n"</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">list</span> pHead = <span class="literal">NULL</span>;</span><br><span class="line">    InitList(&amp;pHead);</span><br><span class="line">    AddNode(pHead);</span><br><span class="line">    PrintList(pHead-&gt;next);</span><br><span class="line">    <span class="comment">// 数字为要删除的结点序号</span></span><br><span class="line">    DeleteSerial(pHead, <span class="number">0</span>);</span><br><span class="line">    DeleteSerial(pHead, <span class="number">6</span>);</span><br><span class="line">    PrintList(pHead-&gt;next);</span><br><span class="line">    OrderAndReverseOrderPrint(pHead);</span><br><span class="line">    AddBySerial(pHead, <span class="number">6</span>, <span class="number">6</span>);</span><br><span class="line">    PrintList(pHead-&gt;next);</span><br><span class="line">    OrderAndReverseOrderPrint(pHead);</span><br><span class="line"></span><br><span class="line">    AddBySerial(pHead, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    PrintList(pHead-&gt;next);</span><br><span class="line">    OrderAndReverseOrderPrint(pHead);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>双向链表</tag>
      </tags>
  </entry>
  <entry>
    <title>图片测试</title>
    <url>/2021/04/21/%E5%9B%BE%E7%89%87%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<p><img src="../images/1.png" alt="hexo功能测试"></p>
]]></content>
      <tags>
        <tag>hexo功能测试</tag>
      </tags>
  </entry>
  <entry>
    <title>合并两个有序链表</title>
    <url>/2020/09/29/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<center>两个有序链表合并为一个有序链表。链表的一个简单操作。</center>

<a id="more"></a>

<h3 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h3><p>今天下午不到一个多小时，好吧，全在搞这个东西。</p>
<p>总结了一下自己为什么这么慢</p>
<p>不是它难，而是方法有问题</p>
<ol>
<li>确定正确的方向：不要空想，一定要看看这个方向走下去到底行不行，否则费事费力最后发现路是死的。在写这个合并有序链表的算法的时候，我竟凭感觉地认为可以不开辟新的内存空间，直接改变原来链表结点之间的指向就可以完成对链表的合并。当然这种算法肯定是存在的，但是目前不在我的能力范围之内。</li>
<li>确定了正确的方向以后，还要在纸上写出整体的关键思路步骤以后，再去敲代码，不要上来就敲，否则敲代码也会走错方向，只不过这个确定的是进一步的具体的代码怎么敲的方向。</li>
</ol>
<h3 id="代码附上"><a href="#代码附上" class="headerlink" title="代码附上"></a>代码附上</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在这里宏定义链表1和链表2的长度</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LISTONE_LEN 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LISTTWO_LEN 6</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; Node, *pNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加结点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddNode</span><span class="params">(pNode, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印链表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintList</span><span class="params">(Node)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并两个链表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeTwoList</span><span class="params">(pNode, pNode, pNode)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 对两个头结点初始化</span></span><br><span class="line">    Node headNode1, headNode2, headNode3;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    headNode1.data = <span class="number">1</span>;</span><br><span class="line">    headNode2.data = <span class="number">2</span>;</span><br><span class="line">    headNode3.data = <span class="number">3</span>;</span><br><span class="line">    headNode1.next = <span class="literal">NULL</span>;</span><br><span class="line">    headNode2.next = <span class="literal">NULL</span>;</span><br><span class="line">    headNode3.next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    AddNode(&amp;headNode1, LISTONE_LEN);</span><br><span class="line"></span><br><span class="line">    AddNode(&amp;headNode2, LISTTWO_LEN);</span><br><span class="line"></span><br><span class="line">    PrintList(headNode1);</span><br><span class="line">    PrintList(headNode2);</span><br><span class="line">    MergeTwoList(&amp;headNode1, &amp;headNode2, &amp;headNode3);</span><br><span class="line">    PrintList(headNode3);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddNode</span><span class="params">(pNode pHeadNode, <span class="keyword">int</span> lenth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    pNode temp = pHeadNode;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; lenth; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pNode pNewNode = (pNode)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        <span class="keyword">if</span> (pHeadNode-&gt;data == <span class="number">1</span>)</span><br><span class="line">            pNewNode-&gt;data = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pNewNode-&gt;data = i * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        temp-&gt;next = pNewNode;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    temp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintList</span><span class="params">(Node headNode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pNode temp = headNode.next;</span><br><span class="line">    <span class="keyword">if</span> (headNode.data == <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"遍历链表1：\n"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (headNode.data == <span class="number">2</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"遍历链表2：\n"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"遍历合并后的链表：\n"</span>);</span><br><span class="line">    <span class="keyword">while</span> (temp != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, temp-&gt;data);</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeTwoList</span><span class="params">(pNode pHeadNode1, pNode pHeadNode2, pNode pHeadNode3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// p, q 分别为两个链表的第一个节点的地址</span></span><br><span class="line">    <span class="comment">// r赋值为第三个链表的头结点的地址</span></span><br><span class="line">    pNode p = pHeadNode1-&gt;next;</span><br><span class="line">    pNode q = pHeadNode2-&gt;next;</span><br><span class="line">    pNode r = pHeadNode3;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span> &amp;&amp; q != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;data &lt; q-&gt;data)</span><br><span class="line">        &#123;</span><br><span class="line">            r-&gt;next = p;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            r = r-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            r-&gt;next = q;</span><br><span class="line">            q = q-&gt;next;</span><br><span class="line">            r = r-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (q == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            r-&gt;next = p;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            r = r-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">while</span> (q != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            r-&gt;next = q;</span><br><span class="line">            q = q-&gt;next;</span><br><span class="line">            r = r-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>链表合并</tag>
      </tags>
  </entry>
  <entry>
    <title>头指针单向链表基本操作</title>
    <url>/2020/10/04/%E5%A4%B4%E6%8C%87%E9%92%88%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>感觉每次自己提前写的东西都和老师讲的书上内容不太一样= =<br>当然大多数是老师讲的更正规一些，毕竟我只是一个会了链表本质就瞎玩的人<br>属于自己琢磨，自己造的那种，很多东西也是不怎么规范<br>但是有的东西我就觉得自己的更好<br>比如下面所说……</p>
<a id="more"></a>

<p>课本上写的是以头指针为基本单位，每次开一个头指针，即可视为开辟了一个链表。</p>
<p>而我参考了动态数组静态数组的写法，将头指针作为了结构体中的一个成员变量，另一个成员变量存储这个链表的长度。每次开一个结构体变量，视为开辟了一个链表。</p>
<p>谈一下我的做法的优越性：</p>
<p>在插入删除的时候，我可以在一开始就判断要插入或删除的结点序号是否存在，因为我有链表的长度，如果结点序号非法，那么直接终止就可以了。然而书上的做法，它只有一个头指针(头结点)，因此在插入删除的时候需要先去遍历，至于结点序号存不存在则需要在遍历完之后才能知道。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在链表尾添加的结点中数据域的内容data</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TAIL_ADD_NODE_DATA_NUMBER 6</span></span><br><span class="line"><span class="comment">// 要删除的结点的序列号</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DELETED_NODE_SERIAL 1</span></span><br><span class="line"><span class="comment">// 要删除的结点中存的数据</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DELETED_NODE_DATA 1</span></span><br><span class="line"><span class="comment">// 初始化的链表长度</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INITIAL_LENGTH 5</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; Node, *List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">pHead</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// 一个头指针可以确定一个链表</span></span><br><span class="line">    List pHead;</span><br><span class="line">    <span class="comment">// 这里标上链表的长度可以省去很多麻烦</span></span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">&#125; LinkList;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintList</span><span class="params">(LinkList)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitializeList</span><span class="params">(LinkList &amp;)</span></span>;</span><br><span class="line"><span class="comment">// 在链表尾添加一个结点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddTail</span><span class="params">(LinkList &amp;, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="comment">// 插入一个 数据域 data = n的结点， 并且使之成为链表中第i个结点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertNode</span><span class="params">(LinkList *, <span class="keyword">int</span> i, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="comment">// 删除第 i 个结点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteNodeBySerialNumber</span><span class="params">(LinkList *, <span class="keyword">int</span> i)</span></span>;</span><br><span class="line"><span class="comment">// 删除 data = n 的结点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteNodeByContainedData</span><span class="params">(LinkList &amp;, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="comment">// 释放链表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FreeList</span><span class="params">(LinkList &amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 每使用一次LinkList，就相当于开辟了一个链表</span></span><br><span class="line">    LinkList <span class="built_in">list</span>;</span><br><span class="line">    <span class="comment">// 初始化链表</span></span><br><span class="line">    <span class="built_in">list</span>.pHead = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">list</span>.length = <span class="number">0</span>;</span><br><span class="line">    InitializeList(<span class="built_in">list</span>);</span><br><span class="line">    PrintList(<span class="built_in">list</span>);</span><br><span class="line">    AddTail(<span class="built_in">list</span>, TAIL_ADD_NODE_DATA_NUMBER);</span><br><span class="line">    PrintList(<span class="built_in">list</span>);</span><br><span class="line">    DeleteNodeBySerialNumber(&amp;<span class="built_in">list</span>, DELETED_NODE_SERIAL);</span><br><span class="line">    PrintList(<span class="built_in">list</span>);</span><br><span class="line">    DeleteNodeBySerialNumber(&amp;<span class="built_in">list</span>, <span class="number">2</span>);</span><br><span class="line">    PrintList(<span class="built_in">list</span>);</span><br><span class="line">    InsertNode(&amp;<span class="built_in">list</span>, <span class="number">1</span>, <span class="number">7</span>);</span><br><span class="line">    PrintList(<span class="built_in">list</span>);</span><br><span class="line">    InsertNode(&amp;<span class="built_in">list</span>, <span class="number">3</span>, <span class="number">8</span>);</span><br><span class="line">    PrintList(<span class="built_in">list</span>);</span><br><span class="line">    InsertNode(&amp;<span class="built_in">list</span>, <span class="number">7</span>, <span class="number">100</span>);</span><br><span class="line">    PrintList(<span class="built_in">list</span>);</span><br><span class="line">    DeleteNodeBySerialNumber(&amp;<span class="built_in">list</span>, <span class="number">7</span>);</span><br><span class="line">    PrintList(<span class="built_in">list</span>);</span><br><span class="line">    FreeList(<span class="built_in">list</span>);</span><br><span class="line">    PrintList(<span class="built_in">list</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"******************************************\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintList</span><span class="params">(LinkList <span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List temp = <span class="built_in">list</span>.pHead;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"当前链表长度为 %d\n"</span>, <span class="built_in">list</span>.length);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">list</span>.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"打印链表内容\n"</span>);</span><br><span class="line">    <span class="keyword">while</span> (temp != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, temp-&gt;data);</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    Print();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitializeList</span><span class="params">(LinkList &amp;<span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"初始化链表...\n"</span>);</span><br><span class="line">    List temp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; INITIAL_LENGTH; i++)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        List p = (List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        p-&gt;data = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">list</span>.pHead = p;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            temp-&gt;next = p;</span><br><span class="line">        temp = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">list</span>.length = INITIAL_LENGTH;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddTail</span><span class="params">(LinkList &amp;<span class="built_in">list</span>, <span class="keyword">int</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"向链表末尾添加 数据域data = %d的结点...\n"</span>, data);</span><br><span class="line">    List p = (List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    p-&gt;data = data;</span><br><span class="line">    p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 检查链表是否为空，如果是空链表，则需要改变头指针</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span>.pHead == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">list</span>.pHead-&gt;next = p;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        List temp = <span class="built_in">list</span>.pHead;</span><br><span class="line">        <span class="keyword">while</span> (temp-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">        temp-&gt;next = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">list</span>.length++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteNodeBySerialNumber</span><span class="params">(LinkList *pList, <span class="keyword">int</span> serial)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!((serial &gt;= <span class="number">1</span>) &amp;&amp; (serial &lt;= pList-&gt;length)))</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"删除第%d个结点..."</span>, serial);</span><br><span class="line">    List deletedNode = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果只删除第一个，要删除的结点是没有上一个结点的，其实找上一个</span></span><br><span class="line">    <span class="comment">// 结点的意义也就无非是要找到这个结点的地址，然后改变上一个结点中指针域</span></span><br><span class="line">    <span class="comment">// 的指向，让上一个结点指向被删除的结点指向的结点。</span></span><br><span class="line">    <span class="comment">// 综上所述，删除结点就是要找到前指针。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (serial == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        deletedNode = pList-&gt;pHead;</span><br><span class="line">        pList-&gt;pHead = pList-&gt;pHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        List temp = pList-&gt;pHead;</span><br><span class="line">        <span class="comment">// 请细细思考for循环中为什么初始化i = 1</span></span><br><span class="line">        <span class="comment">// 并且用 i &lt; serial - 1 作为判断条件</span></span><br><span class="line">        <span class="comment">// 其中有坑</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; serial - <span class="number">1</span>; i++)</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">        deletedNode = temp-&gt;next;</span><br><span class="line">        temp-&gt;next = temp-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(deletedNode);</span><br><span class="line">    pList-&gt;length--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertNode</span><span class="params">(LinkList *pList, <span class="keyword">int</span> serial, <span class="keyword">int</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"在第%d号位插入一个数据域为data = %d的结点...\n"</span>, serial, data);</span><br><span class="line">    <span class="keyword">if</span> (!((serial &gt;= <span class="number">1</span>) &amp;&amp; (serial &lt;= pList-&gt;length + <span class="number">1</span>)))</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    List p = (List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    p-&gt;data = data;</span><br><span class="line">    p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (serial == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p-&gt;next = pList-&gt;pHead;</span><br><span class="line">        pList-&gt;pHead = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        List temp = pList-&gt;pHead;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; serial - <span class="number">1</span>; i++)</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">        p-&gt;next = temp-&gt;next;</span><br><span class="line">        temp-&gt;next = p;</span><br><span class="line">    &#125;</span><br><span class="line">    pList-&gt;length++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FreeList</span><span class="params">(LinkList &amp;<span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"释放链表在堆区开辟的所有空间...\n"</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">list</span>.pHead != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        List deletedNode = <span class="built_in">list</span>.pHead;</span><br><span class="line">        <span class="built_in">list</span>.pHead = (<span class="built_in">list</span>.pHead)-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(deletedNode);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">list</span>.length = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>单链表基本操作</tag>
      </tags>
  </entry>
  <entry>
    <title>广义表之树的兄弟孩子表示法</title>
    <url>/2020/11/17/%E5%B9%BF%E4%B9%89%E8%A1%A8%E4%B9%8B%E6%A0%91%E7%9A%84%E5%85%84%E5%BC%9F%E5%AD%A9%E5%AD%90%E8%A1%A8%E7%A4%BA%E6%B3%95/</url>
    <content><![CDATA[<center>用兄弟孩子广义表来表示二叉树</center>

<a id="more"></a>

<h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p><strong>二叉树转化来的兄弟孩子广义表和普通的兄弟孩子广义表并不相同</strong></p>
<ul>
<li><p>二叉树转换成的兄弟孩子广义表没有明确的一块内存结构来直接表示它是叶子节点还是双亲结点，而是通过 指针 <code>tp</code> 来隐式地表示，<code>tp</code> 指向空，表示它没有孩子节点，否则，有孩子结点</p>
</li>
<li><p>普通的兄弟孩子广义表则是通过 <code>tag</code> = 0 或 1 来表示它是否还有孩子结点</p>
</li>
<li><p>普通的广义表如果转换成树，那么转换成的是只有在叶子结点中存数据的树，根结点，和树中间的双亲节点可以理解成一级一级的括号。</p>
</li>
<li><p>如果还要说不同的话，那就是二叉树中一个双亲结点最多有2 个孩子结点， 而普通的广义表则不同</p>
</li>
<li><p>在求深度的时候，刚开始要设一个 <code>max = 0</code>来表示下一层的深度的最大值， 树转换来的兄弟孩子广义表，下一层只要有结点，那么下一层的深度必为 1 ，直接<code>return max + 1</code>即可，但是普通的广义表，下一层有结点的时候并不能代表下一层的深度就是 1， 因为如果下一层都是 tag为 0 的结点，那么下一层的深度就都是 0 ，不可<code>return max + 1</code>， 需要<code>return max</code>， <code>return max + 1</code> 和 <code>return max</code> 的情况需要 分开讨论</p>
</li>
<li><p>关于两种不同的兄弟孩子广义表求深度时候具体细节的不同，我会在下一期中具体分析</p>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总结一下不同的树 转换成表</p>
<ul>
<li>二叉树  转换成兄弟孩子广义表 (特殊的表，这种表没有<code>tag</code> 的 0 或 1 来表示它是原子结点还是表结点)</li>
<li>普通树 转换成兄弟孩子广义表(特殊的表， 特殊同上)</li>
<li>每一个双亲结点最多有两个孩子结点的兄弟孩子广义表   转换成树(特殊的二叉树， 只有叶子结点存数据)</li>
<li>一个双亲结点可有任意个孩子结点的兄弟孩子广义表 转换成树(特殊的树，只有叶子结点存数据)</li>
</ul>
<h3 id="代码功能"><a href="#代码功能" class="headerlink" title="代码功能"></a>代码功能</h3><ul>
<li>根据输入的一串字符(字符按树的每一层的结点内容输入)，自动建立用兄弟孩子广义表表示的二叉树</li>
<li>先序打印树</li>
<li>转换成兄弟孩子广义表后，在兄弟孩子广义表的基础上求树的深度</li>
</ul>
<h3 id="代码附上"><a href="#代码附上" class="headerlink" title="代码附上"></a>代码附上</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 求树的深度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 兄弟孩子存储结构的树的深度 其实和广义表的兄弟孩子存储结构求深度没有什么区别</span></span><br><span class="line"><span class="comment">// 只不过标识符不一样了， 广义表的标识符是 tag ， 而现在 标识符通过指向左孩子的指针来</span></span><br><span class="line"><span class="comment">// 隐式表示 ， 若指针为空，那么表示这个是一个 叶子节点（即广义表中的原子） 若不为空，则它还有孩子结点</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> Elemtype;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Elemtype data;</span><br><span class="line">    <span class="comment">// 指向本结点左孩子结点的指针，和指向本结点下一个兄弟的指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">hp</span>, *<span class="title">tp</span>;</span></span><br><span class="line">&#125; Node, *Tree;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">(Tree *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过输入一串字符来初始化二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Creat</span><span class="params">(Tree, <span class="keyword">char</span> *, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Creat2</span><span class="params">(Tree, <span class="keyword">char</span> *, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="comment">// 输入一串字符并返回</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">Input</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintTree</span><span class="params">(Tree)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求深度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetDepth</span><span class="params">(Tree)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Tree tree;</span><br><span class="line">    Init(&amp;tree);</span><br><span class="line">    <span class="keyword">char</span> *str = Input();</span><br><span class="line">    Creat(tree, str, <span class="number">0</span>);</span><br><span class="line">    PrintTree(tree-&gt;hp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">int</span> depth = GetDepth(tree-&gt;hp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,depth);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 初始化一个带头结点的二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">(Tree *pTree)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *pTree = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    (*pTree)-&gt;data = <span class="string">'0'</span>;</span><br><span class="line">    (*pTree)-&gt;hp = <span class="literal">NULL</span>;</span><br><span class="line">    (*pTree)-&gt;tp = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">Input</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *s = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * MAX);</span><br><span class="line">    <span class="built_in">memset</span>(s, <span class="string">'0'</span>, <span class="keyword">sizeof</span>(<span class="keyword">char</span>) * MAX);</span><br><span class="line">    gets(s);</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="comment">// 将输入的字符串转化成下标从1开始</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="built_in">strlen</span>(s); i &gt; <span class="number">0</span>; i--)</span><br><span class="line">        s[i] = s[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建一个二叉树</span></span><br><span class="line"><span class="comment">// 刚开始传的参数是  头指针， 字符数组， 0</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Creat</span><span class="params">(Tree tree, <span class="keyword">char</span> *str, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 这个函数的利用价值:</span></span><br><span class="line">    <span class="comment">// 当 i == 0 时，由于传进来的是头指针</span></span><br><span class="line">    <span class="comment">// 并且头指针指向的是头结点，和别的情况不一样</span></span><br><span class="line">    <span class="comment">// 所以需要在递归函数外面单独执行一次</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果根节点就是 '0' 也就代表着这棵树是空的</span></span><br><span class="line">    <span class="keyword">if</span> (str[<span class="number">1</span>] == <span class="string">'0'</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    Node *p = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    p-&gt;data = str[<span class="number">1</span>];</span><br><span class="line">    tree-&gt;hp = p;</span><br><span class="line">    Creat2(p, str, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Creat2</span><span class="params">(Tree tree, <span class="keyword">char</span> *str, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tree-&gt;data = str[i];</span><br><span class="line">    <span class="comment">// 先解决这个结点的hp</span></span><br><span class="line">    <span class="keyword">if</span> (str[i * <span class="number">2</span>] == <span class="string">'0'</span> &amp;&amp; str[i * <span class="number">2</span> + <span class="number">1</span>] == <span class="string">'0'</span>)</span><br><span class="line">        tree-&gt;hp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Node *p = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        tree-&gt;hp = p;</span><br><span class="line">        Creat2(p, str, i * <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 然后解决这个结点的 tp</span></span><br><span class="line">    <span class="keyword">if</span> (str[i + <span class="number">1</span>] == <span class="string">'0'</span> || i % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">        tree-&gt;tp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Node *q = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        tree-&gt;tp = q;</span><br><span class="line">        Creat2(q, str, i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历并打印二叉树</span></span><br><span class="line"><span class="comment">// 传进来的是头结点中存的hp</span></span><br><span class="line"><span class="comment">// 即指向根结点的指针，而不是头指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintTree</span><span class="params">(Tree tree)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"二叉树为空\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c "</span>, tree-&gt;data);</span><br><span class="line">    <span class="keyword">if</span> (tree-&gt;hp)</span><br><span class="line">        PrintTree(tree-&gt;hp);</span><br><span class="line">    <span class="keyword">if</span> (tree-&gt;tp)</span><br><span class="line">        PrintTree(tree-&gt;tp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求深度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetDepth</span><span class="params">(Node *T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!T)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">max</span> = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (Node *temp = T; temp; temp = temp-&gt;tp)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> depth = GetDepth(temp-&gt;hp);</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">max</span> &lt; depth)</span><br><span class="line">			<span class="built_in">max</span> = depth;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">max</span> + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="求深度算法-二"><a href="#求深度算法-二" class="headerlink" title="求深度算法(二)"></a>求深度算法(二)</h3><p>横向纵向都用到了递归，上面那个方法只有纵向用到了递归，横向依靠的是for循环</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 求深度算法 2 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getDep</span><span class="params">(BitTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 空树返回 0</span></span><br><span class="line">    <span class="keyword">if</span> (!T)	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 求当前结点的深度 - 1(既然当前结点存在，其深度必 &gt;= 1)</span></span><br><span class="line">    <span class="keyword">int</span> dep1 = getDep(T-&gt;down);</span><br><span class="line">    <span class="comment">// 求当前结点的兄弟结点的深度</span></span><br><span class="line">    <span class="comment">// 这个语句会在第一次执行的时候不断递归，所以当递归回来到第一次</span></span><br><span class="line">    <span class="comment">// 执行的函数中的时候， dep2已经是第二个结点以及第二个结点之后的所有结点中</span></span><br><span class="line">    <span class="comment">// 深度的最大值, 看似这个递归只比较了两个结点，实则该递归比较了一级中的所有结点</span></span><br><span class="line">    <span class="comment">// 省去了遍历当前层所有结点的操作</span></span><br><span class="line">    <span class="comment">// 横向纵向同时递归</span></span><br><span class="line">    <span class="keyword">int</span> dep2 = getDep(T-&gt;right);</span><br><span class="line">    <span class="comment">// 比较，若当前结点深度 大于 下一个兄弟结点，就返回当前结点深度</span></span><br><span class="line">    <span class="comment">// 否则 返回下一个兄弟结点的深度</span></span><br><span class="line">    <span class="keyword">if</span> (dep1 + <span class="number">1</span> &gt; dep2)</span><br><span class="line">		<span class="keyword">return</span> dep1 + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> dep2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
        <tag>兄弟孩子广义表</tag>
      </tags>
  </entry>
  <entry>
    <title>循环链表的打印 合并</title>
    <url>/2020/10/02/%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%9A%84%E6%89%93%E5%8D%B0-%E5%90%88%E5%B9%B6/</url>
    <content><![CDATA[<p>本文中的所有操作均使用 <strong>设有尾指针的循环链表</strong>完成，目前只写了打印和合并两个操作，后续持续更新~</p>
<a id="more"></a>

<p>看名字都可以知道，<code>使用尾指针的循环链表</code>和<code>使用头指针单链表</code>的区别</p>
<ul>
<li>顾名思义，很容易就看出它们两个有以下这两个区别：</li>
</ul>
<ol>
<li><p>前者没有头指针，只有尾指针，尾指针存的是尾结点的地址，即它指向尾结点，<code>尾指针-&gt;next</code> 就得到了头结点的地址</p>
</li>
<li><p>前者的尾结点指向第一个结点，后者的尾结点中指针域的内容为<code>NULL</code></p>
</li>
</ol>
<p><code>尾指针的循环链表</code>在合并的时候很容易，只需要改变两个尾指针的指向，就可以完成合并工作的 99%，改变两个指针的指向还需要引入一个中间指针变量来存第一个被改变的指针，否者这个指针被改变以后，它指向的内容就找不到了。</p>
<p>假设是链表1接上了链表2，这样的话链表2的尾指针肯定就顺理成章地成为了整个链表的尾指针。那么剩余1 %的细节则是链表1 的尾指针已经失去意义了，销毁掉，或者将它赋值为链表2的值，也就是让它成为合并了以后的链表的尾指针。</p>
<p><strong>代码附上</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 循环链表操作 秀起来~</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CYCLECOUNTS 6</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list</span> * <span class="title">next</span>;</span></span><br><span class="line">&#125;Node;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 放纵不羁爱自由，打印循环链表6次</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CyclePrint</span><span class="params">(Node *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并两个尾指针的循环链表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeList</span><span class="params">(Node **, Node *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印循环链表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(Node *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 开辟两个循环链表</span></span><br><span class="line">	<span class="comment">// 循环链表1    11 -&gt; 12  -&gt;  13  -&gt;  11 ......</span></span><br><span class="line">	<span class="comment">// 循环链表2    21 -&gt; 22  -&gt;  23  -&gt;  24  -&gt;  21 ......</span></span><br><span class="line">	Node * tail_1 = <span class="literal">NULL</span>;</span><br><span class="line">	Node * tail_2 = <span class="literal">NULL</span>;</span><br><span class="line">	Node node11, node12, node13;</span><br><span class="line">	Node node21, node22, node23, node24;</span><br><span class="line">	node11.data = <span class="number">11</span>; node11.next = &amp;node12;</span><br><span class="line">	node12.data = <span class="number">12</span>; node12.next = &amp;node13;</span><br><span class="line">	node13.data = <span class="number">13</span>; node13.next = &amp;node11;</span><br><span class="line">	tail_1 = &amp;node13;</span><br><span class="line">	node21.data = <span class="number">21</span>; node21.next = &amp;node22;</span><br><span class="line">	node22.data = <span class="number">22</span>; node22.next = &amp;node23;</span><br><span class="line">	node23.data = <span class="number">23</span>; node23.next = &amp;node24;</span><br><span class="line">	node24.data = <span class="number">24</span>; node24.next = &amp;node21;</span><br><span class="line">	tail_2 = &amp;node24;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"循环打印%d次\n"</span>, CYCLECOUNTS);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"循环打印链表1\n"</span>);</span><br><span class="line">	CyclePrint(tail_1);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"循环打印链表2\n"</span>);</span><br><span class="line">	CyclePrint(tail_2);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"打印循环链表1\n"</span>);</span><br><span class="line">	Print(tail_1);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"打印循环链表2\n"</span>);</span><br><span class="line">	Print(tail_2);</span><br><span class="line">	MergeList(&amp;tail_1, tail_2);</span><br><span class="line">	<span class="comment">// 两个尾指针现在都指向的是第二个链表尾</span></span><br><span class="line">	<span class="comment">// 故无论传参给谁，都会打印出合并后的链表</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"打印合并后的链表(传参 Node * tail_1)\n"</span>);</span><br><span class="line">	Print(tail_1);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"打印合并后的链表(传参 Node * tail_2)\n"</span>);</span><br><span class="line">	Print(tail_2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(Node * pTail)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">	Node * temp = pTail-&gt;next;</span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d "</span>, temp-&gt;data);</span><br><span class="line">		temp = temp-&gt;next;</span><br><span class="line">	&#125; <span class="keyword">while</span> (temp != pTail-&gt;next);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CyclePrint</span><span class="params">(Node * pTail)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">	Node * temp = pTail-&gt;next;</span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(temp == pTail-&gt;next)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(i == (CYCLECOUNTS + <span class="number">1</span>))</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">if</span>(i == <span class="number">1</span>)</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"第1次循环\n"</span>);</span><br><span class="line">			<span class="keyword">if</span>(i &gt; <span class="number">1</span>)</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"\n第%d次循环\n"</span>, i);</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d "</span>, temp-&gt;data);</span><br><span class="line">		temp = temp-&gt;next;</span><br><span class="line">	&#125; <span class="keyword">while</span> (temp != <span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeList</span><span class="params">(Node** ppTail1, Node * pTail2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Node * temp = (*ppTail1)-&gt;next;</span><br><span class="line">	(*ppTail1)-&gt;next = pTail2-&gt;next;</span><br><span class="line">	pTail2-&gt;next = temp;</span><br><span class="line">	*ppTail1 = pTail2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>打印、合并循环链表</tag>
      </tags>
  </entry>
  <entry>
    <title>循环队列</title>
    <url>/2020/10/22/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<p>循环队列，底层内存结构：静态数组</p>
<p>灵魂思想: 将指针的自增改为   <code>指针 = (指针+ 1) % (数组的真实长度)</code></p>
<a id="more"></a>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 循环队列</span></span><br><span class="line"><span class="comment">// 为了区分空队列和满队列</span></span><br><span class="line"><span class="comment">// 在这里我们认为当整个数组只剩下队尾的那块空间时，队列已满</span></span><br><span class="line"><span class="comment">// 当对头和队尾相等时，列队空</span></span><br><span class="line"><span class="comment">// 因此 队列中成员个数的最大值是 MAX_SIZE - 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_SIZE 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OVER_FLOW -99</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DuiLie</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> arr[MAX_SIZE];</span><br><span class="line">    <span class="comment">// front为队头</span></span><br><span class="line">    <span class="keyword">int</span> front;</span><br><span class="line">    <span class="comment">// pear为队尾</span></span><br><span class="line">    <span class="keyword">int</span> pear;</span><br><span class="line">&#125; Sql;</span><br><span class="line"><span class="comment">// 打印分割线</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DivideLine</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"------------------------------\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 队列的初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitSql</span><span class="params">(Sql *pSql)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pSql-&gt;front = <span class="number">0</span>;</span><br><span class="line">    pSql-&gt;pear = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_SIZE; i++)</span><br><span class="line">        pSql-&gt;arr[i] = i;</span><br><span class="line">    pSql-&gt;front = <span class="number">6</span>;</span><br><span class="line">    pSql-&gt;pear = <span class="number">8</span>;</span><br><span class="line">    <span class="comment">// 队头在6，队尾在3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从队头到队尾依次打印队列元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintSql</span><span class="params">(Sql sql)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 先判断是不是空队列</span></span><br><span class="line">    <span class="keyword">if</span> (sql.front == sql.pear)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"当前队列信息:空队列\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"front下标为 %d, pear 下标为 %d\n"</span>, sql.front, sql.pear);</span><br><span class="line">        DivideLine();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果pear在front的前面那么说明现在是循环队列了</span></span><br><span class="line">    <span class="keyword">int</span> length = ((sql.pear - sql.front) + MAX_SIZE) % MAX_SIZE;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"当前队列长度为 %d\n"</span>, length);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"front下标为 %d, pear 下标为 %d\n"</span>, sql.front, sql.pear);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"打印队列:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, sql.arr[(sql.front + i) % MAX_SIZE]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    DivideLine();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 求队列长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetLength</span><span class="params">(Sql sql)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = (sql.pear - sql.front + MAX_SIZE) % MAX_SIZE;</span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入队</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InSql</span><span class="params">(Sql *pSql, <span class="keyword">int</span> inNumber)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 如果队尾+1 == 队头 即认为队列已满</span></span><br><span class="line">    <span class="comment">// 正常情况下队尾在队头的后面</span></span><br><span class="line">    <span class="comment">// 当循环队列的时候 队尾在队头的前面</span></span><br><span class="line">    <span class="keyword">if</span> (((pSql-&gt;pear + <span class="number">1</span>) % MAX_SIZE) == pSql-&gt;front)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"队列已满！\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 入队的时候，上回的rear指向哪，就往哪里存元素</span></span><br><span class="line">    pSql-&gt;arr[pSql-&gt;pear] = inNumber;</span><br><span class="line">    <span class="comment">// 入队的时候可能会从普通队列转换成循环队列</span></span><br><span class="line">    <span class="comment">// 当入队前pear表示数组的最后一个元素的下标时</span></span><br><span class="line">    <span class="comment">// 数组最后一个元素</span></span><br><span class="line">    pSql-&gt;pear = (pSql-&gt;pear + <span class="number">1</span>) % MAX_SIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出队</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OutSql</span><span class="params">(Sql *pSql, <span class="keyword">int</span> *pOutNumber)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 先判断是不是空队列</span></span><br><span class="line">    <span class="keyword">if</span> (pSql-&gt;front == pSql-&gt;pear)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"空队列...出队失败！\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(OVER_FLOW);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 出队</span></span><br><span class="line">    <span class="comment">// 先将队头元素赋给传进来的变量</span></span><br><span class="line">    *pOutNumber = pSql-&gt;arr[pSql-&gt;front];</span><br><span class="line">    <span class="comment">// 然后改变front表示的下标</span></span><br><span class="line">    pSql-&gt;front = (pSql-&gt;front + <span class="number">1</span>) % MAX_SIZE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Sql sql;</span><br><span class="line">    InitSql(&amp;sql);</span><br><span class="line">    PrintSql(sql);</span><br><span class="line">    <span class="comment">// 要传一个入队元素过去</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        InSql(&amp;sql, i);</span><br><span class="line">        PrintSql(sql);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> outNumber;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        OutSql(&amp;sql, &amp;outNumber);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"取出的队列元素为 %d \n"</span>, outNumber);</span><br><span class="line">        PrintSql(sql);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>循环队列</tag>
      </tags>
  </entry>
  <entry>
    <title>快速排序</title>
    <url>/2020/11/01/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<center>快速排序，分治递归</center>

<a id="more"></a>

<h3 id="主要思想"><a href="#主要思想" class="headerlink" title="主要思想"></a>主要思想</h3><p><strong>分治(二分)递归</strong></p>
<p>取一个标准值，将比标准值小的放在标准值前，比标准值大的放在标准值后。 此操作视为进行了一次快排</p>
<p>然后对标准值前面的子数列和标准值后面的子数列分别进行快排，就这样通过调用递归函数不断地二分…直到第一步快排得到的前面的子数列在不断二分过程中得到的最后一个子数列的标准值和<code>begin</code>相等为止。</p>
<p>二分递归比较难理解，建议在纸上演算一下，整个二分递归的过程就清晰可见了。</p>
<h3 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h3><ol>
<li>取乱序数组的第一个值，作为标准值<code>flag</code></li>
<li>设两个指针<code>begin</code>, <code>end</code> 分别指向数组的第一个元素和最后一个元素</li>
<li>在<code>头尾指针不碰头</code>的情况下，第四步操作和第五步操作一先一后循环执行</li>
<li>末尾指针<code>end</code>向前寻找比标准值<code>flag</code>小的数，找到以后让<code>begin</code>指向的数等于这个比<code>flag</code>小的数，在尾指针向前扫描找比<code>flag</code>小的数的期间如果<code>end</code>和<code>begin</code>碰头了，那么终止程序视为已经完成了一次快排</li>
<li>头指针<code>begin</code>向后寻找比标准值<code>flag</code>大的数，找到以后让<code>end</code>指向的数等于这个比<code>flag</code>大的数</li>
<li>回到第三步判断</li>
<li>第三步和第四、五步中都有对 <code>begin</code>和<code>end</code>是否碰头的判断，不论是在哪一步里碰头，只要碰头就说明一次快排即将结束，但是还少了一步，那就是要将<code>flag</code>要放在最后<code>begin</code>和<code>end</code>重合的位置。   </li>
<li>对<code>flag</code>前面的数进行快排，对<code>flag</code>后面的数进行快排，快排之后又会得到<code>flag</code>…然后继续快排，在递归二分的过程中，前半部分的数列的开始位置始终是原数列的<code>begin</code>， 子数列的结束位置是原数列中索引为<code>上次快排得到的flag的值 - 1</code>，结束后半部分的数列结束的部分始终是原数列的<code>end</code>，子数列的开始位置是原数列中索引为<code>上次快排得到的flag的值 + 1</code></li>
<li>二分递归…</li>
<li>直到第一步快排得到的前面的子数列在不断二分过程中得到的最后一个子数列的标准值和<code>begin</code>相等为止。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LENGTH 10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">single</span><span class="params">(<span class="keyword">int</span> *, <span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">all</span><span class="params">(<span class="keyword">int</span> *, <span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="keyword">int</span> *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">20</span>] = &#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="comment">// 数组的下标为0的位置用于存界值flag</span></span><br><span class="line">    <span class="comment">// 数组长度为10</span></span><br><span class="line">    </span><br><span class="line">    printArray(arr);</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">begin</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">end</span> = <span class="number">9</span>;</span><br><span class="line">    all(arr, <span class="built_in">begin</span>, <span class="built_in">end</span>);</span><br><span class="line">    printArray(arr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="keyword">int</span> *arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; LENGTH; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, arr[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 总排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">all</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> <span class="built_in">begin</span>, <span class="keyword">int</span> <span class="built_in">end</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d \n"</span>, <span class="built_in">begin</span>, <span class="built_in">end</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">begin</span> &lt; <span class="built_in">end</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> flag = single(arr, <span class="built_in">begin</span>, <span class="built_in">end</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, flag);</span><br><span class="line">        <span class="comment">// 递归</span></span><br><span class="line">        all(arr, <span class="built_in">begin</span>, flag - <span class="number">1</span>);</span><br><span class="line">        all(arr, flag + <span class="number">1</span>, <span class="built_in">end</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单个排序</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">single</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> <span class="built_in">begin</span>, <span class="keyword">int</span> <span class="built_in">end</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 将第一个元素记为flag</span></span><br><span class="line">    <span class="keyword">int</span> flag = arr[<span class="built_in">begin</span>];</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">begin</span> != <span class="built_in">end</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">begin</span> &lt; <span class="built_in">end</span> &amp;&amp; arr[<span class="built_in">end</span>] &gt;= flag)</span><br><span class="line">            <span class="built_in">end</span>--;</span><br><span class="line">        arr[<span class="built_in">begin</span>] = arr[<span class="built_in">end</span>];</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">begin</span> &lt; <span class="built_in">end</span> &amp;&amp; arr[<span class="built_in">begin</span>] &lt;= flag)</span><br><span class="line">            <span class="built_in">begin</span>++;</span><br><span class="line">        arr[<span class="built_in">end</span>] = arr[<span class="built_in">begin</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    arr[<span class="built_in">end</span>] = flag;</span><br><span class="line">    printArray(arr);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">end</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>快速排序</tag>
      </tags>
  </entry>
  <entry>
    <title>快排(封装)</title>
    <url>/2020/12/25/%E5%BF%AB%E6%8E%92-%E5%B0%81%E8%A3%85/</url>
    <content><![CDATA[<center>封装好的快速排序</center>

<a id="more"></a>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fastSort</span><span class="params">(<span class="keyword">int</span> *, <span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">single</span><span class="params">(<span class="keyword">int</span> *, <span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fastSort</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> <span class="built_in">begin</span>, <span class="keyword">int</span> <span class="built_in">end</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">begin</span> &lt; <span class="built_in">end</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> flag = single(arr, <span class="built_in">begin</span>, <span class="built_in">end</span>);</span><br><span class="line">        fastSort(arr, <span class="built_in">begin</span>, flag - <span class="number">1</span>);</span><br><span class="line">        fastSort(arr, flag + <span class="number">1</span>, <span class="built_in">end</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">single</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> <span class="built_in">begin</span>, <span class="keyword">int</span> <span class="built_in">end</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> flag = arr[<span class="built_in">begin</span>];</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">begin</span> != <span class="built_in">end</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">begin</span> &lt; <span class="built_in">end</span> &amp;&amp; arr[<span class="built_in">end</span>] &gt;= flag)</span><br><span class="line">            <span class="built_in">end</span>--;</span><br><span class="line">        arr[<span class="built_in">begin</span>] = arr[<span class="built_in">end</span>];</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">begin</span> &lt; <span class="built_in">end</span> &amp;&amp; arr[<span class="built_in">begin</span>] &lt;= flag)</span><br><span class="line">            <span class="built_in">begin</span>++;</span><br><span class="line">        arr[<span class="built_in">end</span>] = arr[<span class="built_in">begin</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    arr[<span class="built_in">end</span>] = flag;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">end</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>排序算法封装</tag>
      </tags>
  </entry>
  <entry>
    <title>随笔</title>
    <url>/2020/11/09/%E6%97%A0%E9%A2%98/</url>
    <content><![CDATA[<p>你要相信 未来要和你共度一生的那个人 其实在与你相同的时间里 也忍受着同样的孤独 那个人也一定 怀着满心期待 拥着一腔孤勇 穿过茫茫人海 要来与你相见</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔 人生</tag>
      </tags>
  </entry>
  <entry>
    <title>直接插入排序</title>
    <url>/2020/12/22/%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<center>直接插入排序，注释中给了比较详细的理解</center>
<a id="more"></a>

<table>
<thead>
<tr>
<th>平均时间复杂度</th>
<th>最坏时间复杂度</th>
<th>空间复杂度</th>
<th>稳定性</th>
</tr>
</thead>
<tbody><tr>
<td>O(n^2)</td>
<td>O(n^2)</td>
<td>O(1)</td>
<td>稳定</td>
</tr>
</tbody></table>
<h3 id="讲解版"><a href="#讲解版" class="headerlink" title="讲解版"></a>讲解版</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 初始化一个数组，0号空间不用，给它赋值成0</span></span><br><span class="line">	<span class="keyword">int</span> arr[<span class="number">11</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">6</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> arrLen = <span class="number">10</span>;</span><br><span class="line">	<span class="comment">// 长度是10， 但是由于0号空间不用，</span></span><br><span class="line">	<span class="comment">// 所以在for循环中，判断条件应该是  &lt; arrLen + 1 或 &lt;= arrLen</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; arrLen + <span class="number">1</span>; i++) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 比前面已经排好的序列的最后一个小，就插入排序，</span></span><br><span class="line">		<span class="comment">// 如果比前面已经排好的序列的最后一个大，说明这个数直接插最后边就行</span></span><br><span class="line">		<span class="comment">// 所以外层循环直接过就可，不用执行 if 中的语句</span></span><br><span class="line">		<span class="keyword">if</span> (arr[i] &lt; arr[i - <span class="number">1</span>])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// 进入这个if 就说明要开始插入的流程了</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">// 复制哨兵</span></span><br><span class="line">			arr[<span class="number">0</span>] = arr[i];</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 给新的数腾地方</span></span><br><span class="line">			<span class="comment">// 因为刚才比较过 arr[i] 和 arr[i - 1]的大小了， </span></span><br><span class="line">			<span class="comment">// 所以在这里直接腾地方就可</span></span><br><span class="line">			arr[i] = arr[i - <span class="number">1</span>];</span><br><span class="line">			<span class="comment">// 接着比较前面的，只要比哨兵中的值(哨兵的值即是要插入的新数的值)大</span></span><br><span class="line">			<span class="comment">// 就往后走一个，给新数腾地方</span></span><br><span class="line">			<span class="comment">// 直到遇见一个 &gt;= 要插入的新数的数，</span></span><br><span class="line">			<span class="comment">// 此时循环中断， j 是第一个比新数大的数的下标，</span></span><br><span class="line">			<span class="comment">// 由于j之后的数都挪地方了, 而j比新数大，所以不挪地方</span></span><br><span class="line">			<span class="comment">// 所以将新数放到 j 指向的位置的下一个就行</span></span><br><span class="line">			<span class="keyword">int</span> j = i - <span class="number">2</span>;</span><br><span class="line">			<span class="keyword">for</span> (j = i - <span class="number">2</span>; arr[j] &gt; arr[<span class="number">0</span>]; j--)</span><br><span class="line">				arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">			arr[j + <span class="number">1</span>] = arr[<span class="number">0</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arrLen + <span class="number">1</span>; i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, arr[i]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="封装版"><a href="#封装版" class="headerlink" title="封装版"></a>封装版</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组封装成数据类型</span></span><br><span class="line"><span class="comment">// 排序封装成函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> arr[MAXSIZE + <span class="number">1</span>];</span><br><span class="line">	<span class="comment">// 数组有效长度不包括0号元素</span></span><br><span class="line">	<span class="comment">// 单纯指有效数据的个数</span></span><br><span class="line">	<span class="keyword">int</span> length;</span><br><span class="line">&#125;Sql;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(Sql *sql)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= sql-&gt;length; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (sql-&gt;arr[i - <span class="number">1</span>] &gt; sql-&gt;arr[i])</span><br><span class="line">		&#123;</span><br><span class="line">			sql-&gt;arr[<span class="number">0</span>] = sql-&gt;arr[i];</span><br><span class="line">			sql-&gt;arr[i] = sql-&gt;arr[i - <span class="number">1</span>];</span><br><span class="line">			<span class="keyword">int</span> j;</span><br><span class="line">			<span class="keyword">for</span> (j = i - <span class="number">2</span>;sql-&gt;arr[j] &gt; sql-&gt;arr[<span class="number">0</span>]; j--)</span><br><span class="line">				sql-&gt;arr[j + <span class="number">1</span>] = sql-&gt;arr[j];</span><br><span class="line">			sql-&gt;arr[j + <span class="number">1</span>] = sql-&gt;arr[<span class="number">0</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Sql sql;</span><br><span class="line">	sql.length = <span class="number">10</span>;</span><br><span class="line">	<span class="comment">// 初始化一个倒序数组</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= sql.length; i++)</span><br><span class="line">		sql.arr[i] = sql.length - i;</span><br><span class="line">	<span class="comment">// 打印排序前的数组</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= sql.length; i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d "</span>, sql.arr[i]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	<span class="comment">// 调用插入排序函数</span></span><br><span class="line">	insertSort(&amp;sql);</span><br><span class="line">	<span class="comment">// 打印排序后的数组</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= sql.length; i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d "</span>, sql.arr[i]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title>此资源非彼资源</title>
    <url>/2021/04/10/%E6%AD%A4%E8%B5%84%E6%BA%90%E9%9D%9E%E5%BD%BC%E8%B5%84%E6%BA%90/</url>
    <content><![CDATA[<center>啃书过程中产生的疑问，最后想通了，并且推广到了一般情况</center>


<a id="more"></a>

<h2 id="问题出处"><a href="#问题出处" class="headerlink" title="问题出处"></a>问题出处</h2><p>计算机操作系统 第四版 P60</p>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在看AND型信号量的Ssignal操作中的一段伪代码的时候产生的疑问，最后我给推广了，也不错，想通了一个事hhh</span><br><span class="line">其中的一段伪代码是这么描述的👇</span><br><span class="line">Remove all the process waiting in the queue associated with si into the ready queue.</span><br><span class="line">将与si关联的队列中等待的所有进程都删除，并移动到就绪队列中</span><br></pre></td></tr></table></figure>

<h2 id="我的分析"><a href="#我的分析" class="headerlink" title="我的分析"></a>我的分析</h2><p>我觉得这么干有些不妥</p>
<p>首先解释一下就绪队列，就绪队列中的进程一定都是就绪状态了吧</p>
<p>那么就绪状态的定义是什么？ 获得了除CPU以外的所有的所需资源</p>
<p>不妥的地方有两个：</p>
<p>第一前面将进程加入阻塞队列的原因是 这个进程只要遇到了一个它想要的但是系统没有的资源就会被送进相应的缺少资源的阻塞队列中，但是并不能保证后面的资源一个也不缺。但是你因为现在这个资源被归还了，就直接把因为判到却这个资源而被放进相应阻塞队列里的进程直接给放进就绪队列里吗？  参考 一下上面的就绪状态的定义</p>
<p>还有就是，即便是这样，你也不能把因为这个资源而进入阻塞队列的所有进程都给激活了吧，你不应该是找一个优先级最高的给激活，放到就绪队列中吗</p>
<p>所以我认为，书上啊  八成是没有表达对，它其实并不是想表达给放进就绪队列中的意思，而是让它解除阻塞，从而可以继续去判断资源是否够用</p>
<h2 id="恍然大悟"><a href="#恍然大悟" class="headerlink" title="恍然大悟"></a>恍然大悟</h2><p>啊..woc 我明白了 确实应该给放进就绪队列里，为啥呢？因为代码运行所需的资源和 你说的那个s1,s2,s3,s4……si 资源不是一个资源，这些东西确实是不够的，但这不是代码运行需要的资源，怎么说呢，代码就是为了实现这个东西而设置的…我也不知道怎么说出来好了， 总之 这俩资源不是一个资源  把运行代码的进程放进就绪队列里是正确的，当它获得CPU以后，就开始继续判断 那几个资源是否足够，够了的话 访问临界区。</p>
<h2 id="推广"><a href="#推广" class="headerlink" title="推广"></a>推广</h2><p>进程运行需要的资源 是内存和CPU等等   我们回到进程的定义   进程是什么？ 进程是程序在一定数据集合上的执行过程 ， 那么进程可以说就是在执行程序  也就是在跑代码，跑代码肯定是不需要太多资源的，这个资源仅仅是内存、CPU….  而 s1,s2,s3,s4,…,sn 这些资源是进程想要访问/使用的资源，这些资源需要通过进程执行wait操作判断, 如果这些资源不够，进程把自己阻塞起来，但是并非因为这些资源  进程就没法运行了，进程运行其实就是跑代码，然后通过跑代码 来判断那些资源够不够，不够的话 把自己阻塞起来，跑代码需要的资源和那些资源不是一回事。当进程被阻塞的时候，它就不能跑代码了，当它被激活的时候，继续去判断信号量的值 从而判断 资源是否可以使用 若可以  则使用资源。 其实这里面也是包含了一些进程阻塞和进程激活的一些本质。</p>
]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>OS</tag>
        <tag>系统资源问题</tag>
        <tag>操作系统</tag>
        <tag>进程阻塞</tag>
        <tag>进程运行</tag>
        <tag>进程激活</tag>
      </tags>
  </entry>
  <entry>
    <title>稀疏矩阵转置</title>
    <url>/2020/10/30/%E7%9F%A9%E9%98%B5%E8%BD%AC%E7%BD%AE%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<center>稀疏矩阵的转置</center>

<a id="more"></a>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_LENGTH 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个用来表示非零元素的结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">a</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// 非零元素的行下标</span></span><br><span class="line">    <span class="keyword">int</span> rowIndex;</span><br><span class="line">    <span class="comment">// 非零元素的列下标</span></span><br><span class="line">    <span class="keyword">int</span> colIndex;</span><br><span class="line">    <span class="comment">// 非零元素的值</span></span><br><span class="line">    <span class="keyword">int</span> number;</span><br><span class="line"></span><br><span class="line">&#125; NotZeroMember;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个表示矩阵的结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">b</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// 开一个数组用于存储非零元素</span></span><br><span class="line">    NotZeroMember <span class="built_in">array</span>[MAX_LENGTH];</span><br><span class="line">    <span class="comment">// 数组长度 即该矩阵中非零元素的个数</span></span><br><span class="line">    <span class="keyword">int</span> arrayLength;</span><br><span class="line">    <span class="comment">// 矩阵的行数和列数</span></span><br><span class="line">    <span class="keyword">int</span> rows, cols;</span><br><span class="line"></span><br><span class="line">&#125; Matrix;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 开一个稀疏矩阵</span></span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">5</span>][<span class="number">7</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">6</span>,</span><br><span class="line">                     <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                     <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                     <span class="number">0</span>, <span class="number">9</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                     <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">8</span>&#125;;</span><br><span class="line">    <span class="comment">// 将稀疏矩阵压缩</span></span><br><span class="line"></span><br><span class="line">    Matrix matrix;</span><br><span class="line">    matrix.rows = <span class="number">5</span>;</span><br><span class="line">    matrix.cols = <span class="number">7</span>;</span><br><span class="line">    matrix.arrayLength = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">7</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i][j] != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 行</span></span><br><span class="line">                matrix.<span class="built_in">array</span>[++matrix.arrayLength].rowIndex = i + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 列</span></span><br><span class="line">                matrix.<span class="built_in">array</span>[matrix.arrayLength].colIndex = j + <span class="number">1</span>;</span><br><span class="line">                matrix.<span class="built_in">array</span>[matrix.arrayLength].number = arr[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= matrix.arrayLength; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d行  %d列  元素值：%d\n"</span>, matrix.<span class="built_in">array</span>[i].rowIndex,</span><br><span class="line">               matrix.<span class="built_in">array</span>[i].colIndex, matrix.<span class="built_in">array</span>[i].number);</span><br><span class="line">    <span class="comment">// 开始转置矩阵</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// num数组用于记录原矩阵每列有几个非0元素</span></span><br><span class="line">    <span class="comment">// num数组中对应的下标就是对应的列序号</span></span><br><span class="line">    <span class="keyword">int</span> num[matrix.cols + <span class="number">1</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= matrix.arrayLength; i++)</span><br><span class="line">        num[matrix.<span class="built_in">array</span>[i].colIndex]++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= matrix.cols; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"第 %d 列有 %d 个非零元素\n"</span>, i, num[i]);</span><br><span class="line">    <span class="comment">// location 数组用于记录转置前每列的首个非零元素(即转置后每行的首个非0元素)</span></span><br><span class="line">    <span class="comment">// 在转置以后的被压缩以后的数组里的下标</span></span><br><span class="line">    <span class="keyword">int</span> location[matrix.cols + <span class="number">1</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= matrix.cols; i++)</span><br><span class="line">        location[i] = location[i - <span class="number">1</span>] + num[i - <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"location数组:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= matrix.cols; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, location[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="comment">// 数组转置</span></span><br><span class="line">    Matrix comperssedMatrix;</span><br><span class="line">    comperssedMatrix.cols = matrix.rows;</span><br><span class="line">    comperssedMatrix.rows = matrix.cols;</span><br><span class="line">    comperssedMatrix.arrayLength = matrix.arrayLength;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= matrix.arrayLength; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t = location[matrix.<span class="built_in">array</span>[i].colIndex];</span><br><span class="line">        comperssedMatrix.<span class="built_in">array</span>[t].number = matrix.<span class="built_in">array</span>[i].number;</span><br><span class="line">        comperssedMatrix.<span class="built_in">array</span>[t].colIndex = matrix.<span class="built_in">array</span>[i].rowIndex;</span><br><span class="line">        comperssedMatrix.<span class="built_in">array</span>[t].rowIndex = matrix.<span class="built_in">array</span>[i].colIndex;</span><br><span class="line">        location[matrix.<span class="built_in">array</span>[i].colIndex]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= comperssedMatrix.arrayLength; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d行  %d列  元素值：%d\n"</span>, comperssedMatrix.<span class="built_in">array</span>[i].rowIndex,</span><br><span class="line">               comperssedMatrix.<span class="built_in">array</span>[i].colIndex, comperssedMatrix.<span class="built_in">array</span>[i].number);</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 打印原来的数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">7</span>; j++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d   "</span>, arr[i][j]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"================\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"-----转置后-----\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"================\n"</span>);</span><br><span class="line">    <span class="comment">// 打印转置后的数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= comperssedMatrix.rows; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= comperssedMatrix.cols; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == comperssedMatrix.<span class="built_in">array</span>[index].rowIndex &amp;&amp; j == comperssedMatrix.<span class="built_in">array</span>[index].rowIndex)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d   "</span>, comperssedMatrix.<span class="built_in">array</span>[index].number);</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"0   "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>稀疏矩阵转置</tag>
      </tags>
  </entry>
  <entry>
    <title>稀疏矩阵乘法</title>
    <url>/2020/11/09/%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95/</url>
    <content><![CDATA[<center>在本算法中，两个稀疏矩阵的特性都有用到</center>

<a id="more"></a>

<h3 id="规定"><a href="#规定" class="headerlink" title="规定"></a>规定</h3><p>规定以下变量名称，本文讲述 矩阵A × 矩阵B = 矩阵C 的运算过程</p>
<p>需要用到的存储结构有： </p>
<ol>
<li>矩阵A，矩阵 B 的原始二维数组(2个)</li>
<li>矩阵A，矩阵B 的三元组数组(2个)</li>
<li>存储 矩阵A，矩阵B 每行有多少个非零元的数组(2个，分别存A、B矩阵)</li>
<li>存储 矩阵B每行首个非零元在三元组数组中的位置的数组(1个)</li>
<li>需要开一个中间数组用于存矩阵C的每一行 （这个中间数组的长度等于B的列数，它只负责在一次循环中记录矩阵C的原始的一行，注意不是稀疏矩阵表示的一样，而是原始矩阵C的一行）</li>
<li>矩阵C 的三元组数组，将稀疏矩阵还原以后的 C的二维数组</li>
</ol>
<p>综上，本算法需要 5 种，9 个数组</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>首先，将上述1 - 4 中的 7 个数组均求出来</p>
<p>一切准备妥当后，且听我慢慢道来</p>
<p>遍历A的三元组数组， 将位于同一行的每个非零元分别与 该非零元的列数 对应到B中的行数，对B中行数是 非零元列数的每个非零元依次求乘法运算并存到中间数组的对应下标位置处，当遍历完A的一行的所有非零元之后，也就求出了C的一行(存在中间数组中，这个中间数组存的不是稀疏的，而是原始矩阵C的一行)，然后再对C进行压缩处理，因为在这个过程中，可能原来不是非零元，在计算完之后成了非零元，压缩完之后存到C的三元组数组中</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>此代码仅仅是将每次内层for循环得到的temp数组(即C矩阵的每一行)打印了出来，还没有做对C矩阵的录入工作，和前面所说稍有出入，还缺个尾巴，但核心算法问题已经解决。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    矩阵 a    4 × 7   8个非零元</span></span><br><span class="line"><span class="comment">    0 8 0 0 6 0 0 </span></span><br><span class="line"><span class="comment">    0 1 0 3 0 0 0 </span></span><br><span class="line"><span class="comment">    7 0 0 2 0 4 0 </span></span><br><span class="line"><span class="comment">    0 0 8 0 0 0 5</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    矩阵 b    7 × 3   6个非零元</span></span><br><span class="line"><span class="comment">    1  0  0</span></span><br><span class="line"><span class="comment">    0  0  2</span></span><br><span class="line"><span class="comment">    0  0  0</span></span><br><span class="line"><span class="comment">    0  9  0 </span></span><br><span class="line"><span class="comment">    3  0  0</span></span><br><span class="line"><span class="comment">    0  0  6</span></span><br><span class="line"><span class="comment">    0  4  0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义非零元的结构体(三元组的基本结构)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">member</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// 矩阵中非零元的 行，列，值</span></span><br><span class="line">    <span class="keyword">int</span> row, col, x;</span><br><span class="line">    </span><br><span class="line">&#125; Member;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义稀疏矩阵</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">matrix</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// 三元组数组</span></span><br><span class="line">    Member *arr;</span><br><span class="line">    <span class="comment">// 矩阵的行数、列数、非零元个数</span></span><br><span class="line">    <span class="keyword">int</span> rows, cols, counts;</span><br><span class="line">    </span><br><span class="line">&#125; Matrix;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化矩阵A的三元组数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitMatrixA</span><span class="params">(Matrix *)</span></span>;</span><br><span class="line"><span class="comment">// 初始化矩阵B的三元组数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitMatrixB</span><span class="params">(Matrix *)</span></span>;</span><br><span class="line"><span class="comment">// 初始化一个三元组数组(在本算法中用于初始化矩阵C的压缩矩阵表示)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitMatrix</span><span class="params">(Matrix *)</span></span>;</span><br><span class="line"><span class="comment">// 以原始形式打印矩阵</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintMatrix</span><span class="params">(Matrix)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求存储了矩阵每一行的第一个非零元在三元组数组中的下标是多少的数组</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">getIndexArr</span><span class="params">(Matrix)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">getCountArr</span><span class="params">(Matrix)</span></span>;</span><br><span class="line"><span class="comment">// 求每一行有多少个非零元</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">getNotZeroSuchRow</span><span class="params">(Matrix)</span></span>;</span><br><span class="line"><span class="comment">// 矩阵乘法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Multiply</span><span class="params">(Matrix, Matrix, <span class="keyword">int</span> *, <span class="keyword">int</span> *, <span class="keyword">int</span> *, <span class="keyword">int</span> *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Matrix a, b;</span><br><span class="line">    InitMatrixA(&amp;a);</span><br><span class="line">    <span class="keyword">int</span> *arrA1 = getIndexArr(a);</span><br><span class="line">    <span class="keyword">int</span> *arrA2 = getNotZeroSuchRow(a);</span><br><span class="line">    InitMatrixB(&amp;b);</span><br><span class="line">    <span class="keyword">int</span> *arrB1 = getIndexArr(b);</span><br><span class="line">    <span class="keyword">int</span> *arrB2 = getNotZeroSuchRow(b);</span><br><span class="line">    Multiply(a, b, arrA1, arrB1, arrA2, arrB2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitMatrixA</span><span class="params">(Matrix *pMatrix)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pMatrix-&gt;cols = <span class="number">7</span>;</span><br><span class="line">    pMatrix-&gt;rows = <span class="number">4</span>;</span><br><span class="line">    pMatrix-&gt;counts = <span class="number">9</span>;</span><br><span class="line">    Member *p = (Member *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Member) * pMatrix-&gt;counts + <span class="number">1</span>);</span><br><span class="line">    p[<span class="number">1</span>].row = <span class="number">1</span>; p[<span class="number">1</span>].col = <span class="number">2</span>; p[<span class="number">1</span>].x = <span class="number">8</span>;</span><br><span class="line">    p[<span class="number">2</span>].row = <span class="number">1</span>; p[<span class="number">2</span>].col = <span class="number">5</span>; p[<span class="number">2</span>].x = <span class="number">6</span>;</span><br><span class="line">    p[<span class="number">3</span>].row = <span class="number">2</span>; p[<span class="number">3</span>].col = <span class="number">2</span>; p[<span class="number">3</span>].x = <span class="number">1</span>;</span><br><span class="line">    p[<span class="number">4</span>].row = <span class="number">2</span>; p[<span class="number">4</span>].col = <span class="number">4</span>; p[<span class="number">4</span>].x = <span class="number">3</span>;</span><br><span class="line">    p[<span class="number">5</span>].row = <span class="number">3</span>; p[<span class="number">5</span>].col = <span class="number">1</span>; p[<span class="number">5</span>].x = <span class="number">7</span>;</span><br><span class="line">    p[<span class="number">6</span>].row = <span class="number">3</span>; p[<span class="number">6</span>].col = <span class="number">4</span>; p[<span class="number">6</span>].x = <span class="number">2</span>;</span><br><span class="line">    p[<span class="number">7</span>].row = <span class="number">3</span>; p[<span class="number">7</span>].col = <span class="number">6</span>; p[<span class="number">7</span>].x = <span class="number">4</span>;</span><br><span class="line">    p[<span class="number">8</span>].row = <span class="number">4</span>; p[<span class="number">8</span>].col = <span class="number">3</span>; p[<span class="number">8</span>].x = <span class="number">8</span>;</span><br><span class="line">    p[<span class="number">9</span>].row = <span class="number">4</span>; p[<span class="number">9</span>].col = <span class="number">7</span>; p[<span class="number">9</span>].x = <span class="number">5</span>;</span><br><span class="line">    pMatrix-&gt;arr = p;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"矩阵A:\n"</span>);</span><br><span class="line">    PrintMatrix(*pMatrix);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitMatrixB</span><span class="params">(Matrix *pMatrix)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pMatrix-&gt;rows = <span class="number">7</span>;</span><br><span class="line">    pMatrix-&gt;cols = <span class="number">3</span>;</span><br><span class="line">    pMatrix-&gt;counts = <span class="number">6</span>;</span><br><span class="line">    Member *p = (Member *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Member) * pMatrix-&gt;counts + <span class="number">1</span>);</span><br><span class="line">    p[<span class="number">1</span>].row = <span class="number">1</span>; p[<span class="number">1</span>].col = <span class="number">1</span>; p[<span class="number">1</span>].x = <span class="number">1</span>;</span><br><span class="line">    p[<span class="number">2</span>].row = <span class="number">2</span>; p[<span class="number">2</span>].col = <span class="number">3</span>; p[<span class="number">2</span>].x = <span class="number">2</span>;</span><br><span class="line">    p[<span class="number">3</span>].row = <span class="number">4</span>; p[<span class="number">3</span>].col = <span class="number">2</span>; p[<span class="number">3</span>].x = <span class="number">9</span>;</span><br><span class="line">    p[<span class="number">4</span>].row = <span class="number">5</span>; p[<span class="number">4</span>].col = <span class="number">1</span>; p[<span class="number">4</span>].x = <span class="number">3</span>;</span><br><span class="line">    p[<span class="number">5</span>].row = <span class="number">6</span>; p[<span class="number">5</span>].col = <span class="number">3</span>; p[<span class="number">5</span>].x = <span class="number">6</span>;</span><br><span class="line">    p[<span class="number">6</span>].row = <span class="number">7</span>; p[<span class="number">6</span>].col = <span class="number">2</span>; p[<span class="number">6</span>].x = <span class="number">4</span>;</span><br><span class="line">    pMatrix-&gt;arr = p;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"矩阵B:\n"</span>);</span><br><span class="line">    PrintMatrix(*pMatrix);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintMatrix</span><span class="params">(Matrix matrix)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= matrix.rows; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= matrix.cols; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == matrix.arr[index].row &amp;&amp; j == matrix.arr[index].col)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d "</span>, matrix.arr[index++].x);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"0 "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">getIndexArr</span><span class="params">(Matrix matrix)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 要返回的目的数组</span></span><br><span class="line">    <span class="keyword">int</span> *p = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * matrix.rows);</span><br><span class="line">    <span class="comment">// 求每一行有多少个非0元的数组</span></span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= matrix.counts; i++)</span><br><span class="line">        arr[matrix.arr[i].row]++;</span><br><span class="line">    p[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= matrix.rows; i++)</span><br><span class="line">        p[i] = p[i - <span class="number">1</span>] + arr[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">getNotZeroSuchRow</span><span class="params">(Matrix matrix)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (matrix.rows + <span class="number">1</span>));</span><br><span class="line">    <span class="comment">// 将每个数组元素初始化为0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.rows + <span class="number">1</span>; i++)</span><br><span class="line">        p[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= matrix.counts; i++)</span><br><span class="line">        p[matrix.arr[i].row]++;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Multiply</span><span class="params">(Matrix a, Matrix b, <span class="keyword">int</span> *arr1, <span class="keyword">int</span> *brr1, <span class="keyword">int</span> *arr2, <span class="keyword">int</span> *brr2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *temp = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (b.cols + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; b.cols + <span class="number">1</span>; i++)</span><br><span class="line">        temp[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"矩阵 C = A × B:\n"</span>);</span><br><span class="line">    <span class="comment">// arr和brr分别存储了矩阵A矩阵B每行首个非零元在三元组数组中的下标</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= a.rows; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= arr2[i]; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// a的三元组数组中每个元素的列数</span></span><br><span class="line">            Member aMember = a.arr[index];</span><br><span class="line">            <span class="keyword">int</span> colOfSuchMemberA = aMember.col;</span><br><span class="line">            <span class="comment">// 去b矩阵的brr数组中找到行为上面得到的列数的第一个非零元的下标</span></span><br><span class="line">            <span class="keyword">int</span> indexOfNotZeroOfRowOfB = brr1[colOfSuchMemberA];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= brr2[colOfSuchMemberA]; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                Member bMember = b.arr[indexOfNotZeroOfRowOfB + i - <span class="number">1</span>];</span><br><span class="line">                temp[bMember.col] += bMember.x * aMember.x;</span><br><span class="line">            &#125;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 内层循环一次，代表C矩阵的一行已经被计算出来</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= b.cols; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>, temp[i]);</span><br><span class="line">            temp[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>稀疏矩阵运算</tag>
      </tags>
  </entry>
  <entry>
    <title>自动生成完全二叉树</title>
    <url>/2020/12/25/%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<center>需要写完全二叉树的算法时，再也不用费时间去初始化一个二叉树了hh~</center>

<a id="more"></a>

<h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><p><code>二叉链表</code>， 如果要写的算法不是基于<code>二叉链表</code>，那么肯定就偷不了懒啦</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>基本思路就是直接生成一个数组长度length的节点</p>
<p>然后利用<code>完全二叉树</code>的性质和数组的下标把它们串起来</p>
<p><strong>要用到的<code>完全二叉树</code>的性质</strong></p>
<ol>
<li>分支节点个数 = 总节点个数 整除 2  (在数学中就是 除以二 再向下取整)</li>
<li>序号为 i 的分支节点的左孩子的序号为 2 * i, 右孩子的序号为 2 * i + 1</li>
<li>最后一个分支节点的序号为 总结点个数 整除 2 </li>
<li>第一个叶子节点的序号为 总结点个数 整除 2 再 加一</li>
</ol>
<h2 id="代码附上"><a href="#代码附上" class="headerlink" title="代码附上"></a>代码附上</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 生成完全二叉树</span></span><br><span class="line"><span class="comment">// 完全二叉树的存储结构为二叉链表</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">treeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">treeNode</span> *<span class="title">left</span>, *<span class="title">right</span>;</span></span><br><span class="line">&#125;TreeNode, *Tree;</span><br><span class="line"></span><br><span class="line"><span class="function">Tree <span class="title">initTree</span><span class="params">(<span class="keyword">int</span> nodeCounts)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (nodeCounts &lt; <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 这个操作仅仅是让p指向申请的那块空间的首地址，p不是树的头指针</span></span><br><span class="line">    Tree p = (Tree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TreeNode) * (nodeCounts + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nodeCounts; i++)</span><br><span class="line">        p[i].data = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nodeCounts / <span class="number">2</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p[i].left = p + <span class="number">2</span> * i;</span><br><span class="line">        p[i].right = p + <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nodeCounts / <span class="number">2</span> + <span class="number">1</span>; i &lt;= nodeCounts; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p[i].left = <span class="literal">NULL</span>;</span><br><span class="line">        p[i].right = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>完全二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>简单选择排序</title>
    <url>/2020/12/22/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<center>选择排序 ，最简单的排序算法之一</center>
<a id="more"></a>

<table>
<thead>
<tr>
<th>平均时间复杂度</th>
<th>最坏时间复杂度</th>
<th>空间复杂度</th>
<th>稳定性</th>
</tr>
</thead>
<tbody><tr>
<td>O(n^2)</td>
<td>O(n^2)</td>
<td>O(1)</td>
<td>不稳定</td>
</tr>
</tbody></table>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 选择排序</span></span><br><span class="line"><span class="comment">// 首先通过 n –1 次关键字比较，从 n 个记录中找出关键</span></span><br><span class="line"><span class="comment">// 字最小的记录，将它与第一个记录交换。 </span></span><br><span class="line"><span class="comment">// 再通过 n –2 次比较，从剩余的 n –1 个记录中找出关键</span></span><br><span class="line"><span class="comment">// 字次小的记录，将它与第二个记录交换。 </span></span><br><span class="line"><span class="comment">// 重复上述操作，共进行 n –1 趟排序后，排序结束</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 半年前看这个什么选择排序插入排序的时候还很头疼</span></span><br><span class="line"><span class="comment">// 那个时候代码写的少，算法思维也不是很足</span></span><br><span class="line"><span class="comment">// 还是很感谢大二上的数据结构这门课哈，</span></span><br><span class="line"><span class="comment">// 虽然代码实现那些数据结构中算法的时候都是一路被虐</span></span><br><span class="line"><span class="comment">// 不过确实写代码的能力包括思维提升了不少</span></span><br><span class="line"><span class="comment">// 等境界高一些之后回头再看当初迈不过去的坎时</span></span><br><span class="line"><span class="comment">// 发现其实很简单了</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数为数组首地址和数组长度</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span> *, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> arr[<span class="number">10</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		arr[i] = <span class="number">10</span> - i;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d "</span>, arr[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	selectSort(arr, <span class="number">10</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d "</span>, arr[i]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// n是长度</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> <span class="built_in">min</span> = i;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[j] &lt; arr[<span class="built_in">min</span>])</span><br><span class="line">				<span class="built_in">min</span> = j;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> t = arr[<span class="built_in">min</span>];</span><br><span class="line">		arr[<span class="built_in">min</span>] = arr[i];</span><br><span class="line">		arr[i] = t;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title>学生信息管理系统</title>
    <url>/2020/07/01/%E9%93%BE%E8%A1%A8%E9%A1%B9%E7%9B%AE-%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>这是一个用C语言实现，以单向链表为核心，用于管理数据的小项目，功能尚不完备，后续持续更新。</p>
<a id="more"></a>

<h2 id="核心知识"><a href="#核心知识" class="headerlink" title="核心知识"></a>核心知识</h2><p>单向链表基本操作+对文件的基本操作</p>
<h2 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h2><ul>
<li>请先建好一个<code>.txt</code> 文件并记下路径名，文件可以为空，也可以预先存好数据</li>
<li>建议创建一个空文件，通过程序来向文件中存数据。</li>
<li>手动去文件中存数据需要严格按照格式。</li>
</ul>
<blockquote>
<h3 id="预先存好的数据需要按照以下格式："><a href="#预先存好的数据需要按照以下格式：" class="headerlink" title="预先存好的数据需要按照以下格式："></a><strong>预先存好的数据需要按照以下格式：</strong></h3><hr>
<p>姓名1    语文    数学    英语    计算机    C语言    平均分    总分1<br>…<br>姓名n    语文    数学    英语    计算机    C语言    平均分    总分n</p>
<hr>
<h3 id="按照上述格式存数据的同时，需要注意以下两点："><a href="#按照上述格式存数据的同时，需要注意以下两点：" class="headerlink" title="按照上述格式存数据的同时，需要注意以下两点："></a>按照上述格式存数据的同时，需要注意以下两点：</h3><ol>
<li>某些编译器不支持中文字符的读写操作(VS2012支持)，因此，<code>姓名</code>可能不支持中文。<br> <strong>不论是预先在文件里存数据，还是通过程序向文件中存数据，都应该注意这一点。</strong></li>
<li>文件结尾，也就是文件内容的最后一行的<code>总分n</code>后面<code>不要有任何字符</code>。</li>
</ol>
</blockquote>
<h2 id="代码附上"><a href="#代码附上" class="headerlink" title="代码附上"></a>代码附上</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXNAME 30</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSUBJECT 5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SPACE <span class="meta-string">' '</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[MAXNAME];</span><br><span class="line">    <span class="keyword">int</span> score[MAXSUBJECT];</span><br><span class="line">    <span class="keyword">double</span> aver;</span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line"></span><br><span class="line">&#125; STUDENT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    STUDENT data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">&#125; NODE, *LIST;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i, choice;</span><br><span class="line"><span class="keyword">char</span> ch, c, c2;</span><br><span class="line"><span class="keyword">char</span> s1[<span class="number">10</span>] = <span class="string">"name"</span>;</span><br><span class="line"><span class="keyword">char</span> s2[<span class="number">10</span>] = <span class="string">"average"</span>;</span><br><span class="line"><span class="keyword">char</span> s3[<span class="number">10</span>] = <span class="string">"sum"</span>;</span><br><span class="line"><span class="keyword">char</span> s4[<span class="number">10</span>] = <span class="string">"chinese"</span>;</span><br><span class="line"><span class="keyword">char</span> s5[<span class="number">10</span>] = <span class="string">"math"</span>;</span><br><span class="line"><span class="keyword">char</span> s6[<span class="number">10</span>] = <span class="string">"english"</span>;</span><br><span class="line"><span class="keyword">char</span> s7[<span class="number">10</span>] = <span class="string">"computer"</span>;</span><br><span class="line"><span class="keyword">char</span> s8[<span class="number">10</span>] = <span class="string">"c"</span>;</span><br><span class="line"><span class="keyword">char</span> FileName[<span class="number">100</span>];</span><br><span class="line">LIST headp = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读入文件时，添加链表成员</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddFscanf</span><span class="params">(NODE)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用说明</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Instructions</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进行完一次操作后，询问是否继续</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Ask</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印分割线</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SplitLine</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作1，用户输入时，添加链表成员，</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddUserInput</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作2，删除节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delete</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作3，查询某个节点信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Inquire</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作4，更新某个节点信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作5，排序学生信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Sort</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作6，保存信息到文件中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Save</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作7，打印链表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放链表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Free</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    FILE *fp = <span class="literal">NULL</span>;</span><br><span class="line">    NODE head;</span><br><span class="line">    NODE temp;</span><br><span class="line">    headp = &amp;head;</span><br><span class="line">    head.next = <span class="literal">NULL</span>;</span><br><span class="line">    temp.next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入文件的绝对路径+文件名(仅限 .txt 文件)\n\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"例如，若您要打开D盘根目录下的 info.txt 文件\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"则应输入\"D:/info.txt\"(您输入的字符均应为英文字符)\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, FileName);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">if</span> ((fp = fopen(FileName, <span class="string">"r"</span>)) == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n\"%s\" 打开失败\n\n"</span>, FileName);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n\"%s\" 打开成功!\n"</span>, FileName);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n正在鉴定文件是否为空...\n"</span>);</span><br><span class="line">    c2 = getc(fp);</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">if</span> (c2 == EOF)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"打开的文件为空文件，仅可进行写入操作！\n"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"文件非空，可进行任意操作\n\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"正在重新打开该文件...\n"</span>);</span><br><span class="line">        <span class="keyword">if</span> ((fp = fopen(FileName, <span class="string">"r"</span>)) == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"can't open \"%s\" \n"</span>, FileName);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"正在读取该文件中的数据...\n"</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fscanf</span>(fp, <span class="string">"%s"</span>, temp.data.name);</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXSUBJECT; i++)</span><br><span class="line">                <span class="built_in">fscanf</span>(fp, <span class="string">"%d"</span>, &amp;temp.data.score[i]);</span><br><span class="line">            <span class="built_in">fscanf</span>(fp, <span class="string">"%lf"</span>, &amp;temp.data.aver);</span><br><span class="line">            <span class="built_in">fscanf</span>(fp, <span class="string">"%d"</span>, &amp;temp.data.sum);</span><br><span class="line">            ch = getc(fp);</span><br><span class="line">            AddFscanf(temp);</span><br><span class="line">            <span class="keyword">if</span> (ch == EOF)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"文件数据读取成功!\n"</span>);</span><br><span class="line">        fclose(fp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Instructions();</span><br><span class="line">        <span class="keyword">switch</span> (choice)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            AddUserInput();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            Delete();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            Inquire();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            Update();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">            Sort();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">            Save();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">            Print();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Bye~  Have a good day! \n\n"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Ask();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Free();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Free</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LIST temp = headp-&gt;next;</span><br><span class="line">    LIST deletep = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (temp != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        deletep = temp;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(deletep);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Save</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *fp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    LIST temp = headp-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> ((fp = fopen(FileName, <span class="string">"w"</span>)) == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"can't open \" %s \" \n"</span>, FileName);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (temp != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag)</span><br><span class="line">            <span class="built_in">fprintf</span>(fp, <span class="string">"\n"</span>);</span><br><span class="line">        <span class="built_in">fprintf</span>(fp, <span class="string">"%s   "</span>, temp-&gt;data.name);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXSUBJECT; i++)</span><br><span class="line">            <span class="built_in">fprintf</span>(fp, <span class="string">"%d   "</span>, temp-&gt;data.score[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">fprintf</span>(fp, <span class="string">"%.2f   "</span>, temp-&gt;data.aver);</span><br><span class="line">        <span class="built_in">fprintf</span>(fp, <span class="string">"%d"</span>, temp-&gt;data.sum);</span><br><span class="line">        flag = <span class="number">1</span>;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n保存成功!"</span>);</span><br><span class="line">    fclose(fp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Sort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LIST temp = <span class="literal">NULL</span>;</span><br><span class="line">    STUDENT t;</span><br><span class="line">    <span class="keyword">int</span> lenth = <span class="number">0</span>, j;</span><br><span class="line">    <span class="keyword">if</span> (headp-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"数据为空!仅可进行写入操作!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    temp = headp-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (temp != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        lenth++;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = lenth - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        temp = headp-&gt;next;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp-&gt;data.sum &lt; temp-&gt;next-&gt;data.sum)</span><br><span class="line">            &#123;</span><br><span class="line">                t = temp-&gt;data;</span><br><span class="line">                temp-&gt;data = temp-&gt;next-&gt;data;</span><br><span class="line">                temp-&gt;next-&gt;data = t;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (temp-&gt;data.sum == temp-&gt;next-&gt;data.sum)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">strcmp</span>(temp-&gt;data.name, temp-&gt;next-&gt;data.name) &gt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    t = temp-&gt;data;</span><br><span class="line">                    temp-&gt;data = temp-&gt;next-&gt;data;</span><br><span class="line">                    temp-&gt;next-&gt;data = t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n排序成功!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LIST temp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> flag;</span><br><span class="line">    <span class="keyword">char</span> NAME[MAXNAME];</span><br><span class="line">    <span class="keyword">if</span> (headp-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"数据为空!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    temp = headp;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入要更新的学生姓名:\n"</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        temp = headp;</span><br><span class="line">        fflush(<span class="built_in">stdin</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, NAME);</span><br><span class="line">        getchar();</span><br><span class="line">        <span class="keyword">while</span> (temp != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strcmp</span>(temp-&gt;data.name, NAME) == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (temp == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"错误！库中没有该学生的信息\n"</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"键入'n'退出该功能，或键入'y'重新输入\n"</span>);</span><br><span class="line">            <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                flag = <span class="number">0</span>;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%c"</span>, &amp;c);</span><br><span class="line">                getchar();</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="string">'y'</span> || c == <span class="string">'Y'</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"请重新输入要更新学生的姓名\n"</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'n'</span> || c == <span class="string">'N'</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    flag = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"输入非法!请输入'y'或'n',不要输入其它字符\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            temp-&gt;data.sum = <span class="number">0</span>;</span><br><span class="line">            temp-&gt;data.aver = <span class="number">0.0</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"请依次输入该学生语文、数学、英语、计算机、C语言，五门课的成绩\n"</span>);</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXSUBJECT; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;temp-&gt;data.score[i]);</span><br><span class="line">                temp-&gt;data.sum += temp-&gt;data.score[i];</span><br><span class="line">            &#125;</span><br><span class="line">            temp-&gt;data.aver = temp-&gt;data.sum * <span class="number">1.0</span> / MAXSUBJECT;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n更新成功!"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Inquire</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LIST temp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> flag;</span><br><span class="line">    <span class="keyword">char</span> NAME[MAXNAME];</span><br><span class="line">    <span class="keyword">if</span> (headp-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"数据为空!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    temp = headp;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入要查询的学生姓名:\n"</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        temp = headp;</span><br><span class="line">        fflush(<span class="built_in">stdin</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, NAME);</span><br><span class="line">        getchar();</span><br><span class="line">        <span class="keyword">while</span> (temp != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strcmp</span>(temp-&gt;data.name, NAME) == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (temp == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"错误！库中没有该学生的信息\n"</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"键入'y'重新输入或'n'退出该功能\n"</span>);</span><br><span class="line">            <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                flag = <span class="number">0</span>;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%c"</span>, &amp;c);</span><br><span class="line">                getchar();</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="string">'y'</span> || c == <span class="string">'Y'</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"请重新输入要查询学生的姓名\n"</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'n'</span> || c == <span class="string">'N'</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    flag = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"输入非法!请输入'y'或'n',不要输入其它字符\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n\n%s的信息如下:\n\n"</span>, NAME);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%-10s %-8s %-10s %-10s %-10s %-10s %6s\n"</span>,</span><br><span class="line">                   s2, s3, s4, s5, s6, s7, s8);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%-10.2f %-10d"</span>,</span><br><span class="line">                   temp-&gt;data.aver, temp-&gt;data.sum);</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXSUBJECT; i++)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%-12d"</span>, temp-&gt;data.score[i]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delete</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LIST temp = <span class="literal">NULL</span>, deletp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> flag;</span><br><span class="line">    <span class="keyword">char</span> NAME[MAXNAME];</span><br><span class="line">    <span class="keyword">if</span> (headp-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"数据为空!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    temp = headp;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入要删除的学生的姓名:\n"</span>);</span><br><span class="line">    <span class="comment">// 现在这个情况，链表一定不为空</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        temp = headp;</span><br><span class="line">        fflush(<span class="built_in">stdin</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, NAME);</span><br><span class="line">        getchar();</span><br><span class="line">        <span class="comment">// 搜索要删除的学生姓名所在结点的上一个</span></span><br><span class="line">        <span class="keyword">while</span> (temp-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strcmp</span>(temp-&gt;next-&gt;data.name, NAME) == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (temp-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            flag = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"您要删除的学生不存在,键入'y'重新输入或'n'退出该功能\n"</span>);</span><br><span class="line">            <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                c = getchar();</span><br><span class="line">                getchar();</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="string">'y'</span> || c == <span class="string">'Y'</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"请重新输入学生姓名:\n"</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'n'</span> || c == <span class="string">'N'</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    flag = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"输入非法!请重新输入'y' or 'n'\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 要删除的结点是最后一个结点</span></span><br><span class="line">            <span class="keyword">if</span> (temp-&gt;next-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">free</span>(temp-&gt;next);</span><br><span class="line">                temp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                deletp = temp-&gt;next;</span><br><span class="line">                temp-&gt;next = temp-&gt;next-&gt;next;</span><br><span class="line">                <span class="built_in">free</span>(deletp);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n删除成功!"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Ask</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fflush(<span class="built_in">stdin</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n\n输入'n'结束该信息管理系统，或输入其它任意字符回到菜单\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%c"</span>, &amp;c);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="string">'n'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\nBye~  Have a good day! \n\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddUserInput</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>, flag2 = <span class="number">0</span>;</span><br><span class="line">    LIST newp = <span class="literal">NULL</span>;</span><br><span class="line">    LIST temp = headp-&gt;next;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入学生姓名:\n"</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        newp = (LIST)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(NODE));</span><br><span class="line">        flag = <span class="number">0</span>;</span><br><span class="line">        temp = headp-&gt;next;</span><br><span class="line">        fflush(<span class="built_in">stdin</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, newp-&gt;data.name);</span><br><span class="line">        getchar();</span><br><span class="line">        <span class="keyword">while</span> (temp != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strcmp</span>(newp-&gt;data.name, temp-&gt;data.name) == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n库中已有该名字，请退回到菜单选择\"更新信息\"或选择重新输入名字\n"</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"是否重新输入?(y/n)\n"</span>);</span><br><span class="line">            <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                flag2 = <span class="number">0</span>;</span><br><span class="line">                c = getchar();</span><br><span class="line">                getchar();</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="string">'y'</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"\n您选择了'y',请重新输入名字\n"</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'n'</span>)</span><br><span class="line">                &#123;</span><br><span class="line"></span><br><span class="line">                    flag2 = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"\n请输入'y'或'n'，不要输入其它字符!\n"</span>);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"请重新输入'y'或'n' \n"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag2)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            temp = headp;</span><br><span class="line">            <span class="keyword">while</span> (temp-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">                temp = temp-&gt;next;</span><br><span class="line">            temp-&gt;next = newp;</span><br><span class="line">            newp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            newp-&gt;data.sum = <span class="number">0</span>;</span><br><span class="line">            newp-&gt;data.aver = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"请依次输入该学生语文、数学、英语、计算机、C语言，五门课的成绩\n"</span>);</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXSUBJECT; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;newp-&gt;data.score[i]);</span><br><span class="line">                newp-&gt;data.sum += newp-&gt;data.score[i];</span><br><span class="line">            &#125;</span><br><span class="line">            newp-&gt;data.aver = newp-&gt;data.sum * <span class="number">1.0</span> / MAXSUBJECT;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n添加成功!\n"</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"是否继续添加?(输入'n'结束该功能，输入其它任意字符继续添加)\n"</span>);</span><br><span class="line">            fflush(<span class="built_in">stdin</span>);</span><br><span class="line">            c = getchar();</span><br><span class="line">            getchar();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'n'</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"\n请继续输入要添加的学生的姓名\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddFscanf</span><span class="params">(NODE newNode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LIST newp = (LIST)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(NODE));</span><br><span class="line">    LIST temp = headp;</span><br><span class="line">    <span class="keyword">while</span> (temp-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">    temp-&gt;next = newp;</span><br><span class="line">    newp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    newp-&gt;data.sum = <span class="number">0</span>;</span><br><span class="line">    newp-&gt;data.aver = <span class="number">0.0</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(newp-&gt;data.name, newNode.data.name);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXSUBJECT; i++)</span><br><span class="line">        newp-&gt;data.score[i] = newNode.data.score[i];</span><br><span class="line">    newp-&gt;data.sum = newNode.data.sum;</span><br><span class="line">    newp-&gt;data.aver = newNode.data.aver;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LIST temp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (headp-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"数据为空!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    temp = headp;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"已存储的数据为:\n"</span>);</span><br><span class="line">    SplitLine();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%-15s %-10s %-8s %-10s %-10s %-10s %-10s %6s\n"</span>,</span><br><span class="line">           s1, s2, s3, s4, s5, s6, s7, s8);</span><br><span class="line">    <span class="keyword">while</span> (temp-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%-15s %-10.2f %-10d"</span>,</span><br><span class="line">               temp-&gt;next-&gt;data.name, temp-&gt;next-&gt;data.aver,</span><br><span class="line">               temp-&gt;next-&gt;data.sum);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXSUBJECT; i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%-12d"</span>, temp-&gt;next-&gt;data.score[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    SplitLine();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SplitLine</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n========================================================================================\n\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Instructions</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n\n\t   The Student's Grade Management System\n\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"---------------------Student  Menu------------------------\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (headp-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"* 1 输入学生信息\t\t\t * 0 退出学生系统\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"----------------------------------------------------------\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"此时数据为空!仅支持输入学生信息！\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Enter your choice 0 or 1: "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"* 1 输入学生信息\t\t\t * 2 删除学生信息\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"* 3 查询学生信息\t\t\t * 4 更新学生信息\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"* 5 排序学生信息\t\t\t * 6 保存学生信息\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"* 7 显示学生信息\t\t\t * 0 退出学生系统\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"----------------------------------------------------------\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Enter your choice [0 - 7]: "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;choice);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>链表小项目</tag>
      </tags>
  </entry>
  <entry>
    <title>非递归后序遍历二叉树</title>
    <url>/2020/12/25/%E9%9D%9E%E9%80%92%E5%BD%92%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<center>使用栈实现后序遍历二叉树</center>

<a id="more"></a>

<p>写了很久很久很久，可能是自己太长时间没写这样的代码了吧，简直把自己写崩溃了，不过还好，终于算是写出来了。有的是写了才发现存储结构开的不对， 有的是平时没有遇到的比较神奇的bug   也不算是神奇吧，就是平时没有遇见过的问题，也算是有收获了。爱瞎搞，爱作，可不就遇到很多阴间问题呗~ hhhhhh  </p>
<p>里边附带了一个自己瞎搞想出来的偷懒生成满二叉树的办法，可以用来当测试的背景</p>
<p>写一下自己的收获吧</p>
<ol>
<li>枚举体的默认值不是 值为0的那个，需要手动初始化</li>
<li>树要带头指针</li>
<li>栈中存的应该是树中结点的地址，而不是每个节点，要是把栈里的元素给设置成树的节点的话，好家伙，也太浪费内存了，并且，还不好操作，需要来回转换</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span></span><br><span class="line">&#123;</span><br><span class="line">	unvisit, visit</span><br><span class="line">&#125;VisitTag;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">treeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">treeNode</span> *<span class="title">left</span>, *<span class="title">right</span>;</span></span><br><span class="line">	VisitTag tag;</span><br><span class="line">&#125;TreeNode, *Tree;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 栈里存的应该是每个结点的地址</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">stack</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	Tree arr[MAXSIZE];</span><br><span class="line">	<span class="keyword">int</span> top;</span><br><span class="line">&#125; Stack;</span><br><span class="line"></span><br><span class="line"><span class="function">Tree <span class="title">initTree</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initStack</span><span class="params">(Stack *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(Tree, Stack *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inStack</span><span class="params">(Stack *, Tree)</span></span>;</span><br><span class="line"><span class="function">Tree <span class="title">outStack</span><span class="params">(Stack *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Tree t = initTree(<span class="number">15</span>);</span><br><span class="line">	Stack <span class="built_in">stack</span>;</span><br><span class="line">	initStack(&amp;<span class="built_in">stack</span>);</span><br><span class="line">	postOrder(t, &amp;<span class="built_in">stack</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(Tree t, Stack *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Tree temp = t;</span><br><span class="line">	<span class="comment">// 当指针指向空且栈中没有元素时, 终止循环</span></span><br><span class="line">	<span class="keyword">while</span>(temp != <span class="literal">NULL</span> || s-&gt;top != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (temp != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			inStack(s, temp);</span><br><span class="line">			temp = temp-&gt;left;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Tree p = s-&gt;arr[(s-&gt;top) - <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">if</span> (p-&gt;tag == unvisit)</span><br><span class="line">		&#123;  <span class="comment">// 第一次被访问</span></span><br><span class="line">			p-&gt;tag = visit;</span><br><span class="line">			temp = p-&gt;right;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123; <span class="comment">// 第二次被访问, 栈顶元素出栈, 打印栈顶元素</span></span><br><span class="line">			outStack(s);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, p-&gt;data);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化栈</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initStack</span><span class="params">(Stack *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	p-&gt;top = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入栈</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inStack</span><span class="params">(Stack *s, Tree p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (s-&gt;top &gt;= MAXSIZE)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"栈已满, 入栈失败\n"</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	s-&gt;arr[s-&gt;top] = p;</span><br><span class="line">	s-&gt;top++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出栈</span></span><br><span class="line"><span class="function">Tree <span class="title">outStack</span><span class="params">(Stack *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (s-&gt;top == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"栈为空, 出栈失败\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	s-&gt;top--;</span><br><span class="line">	<span class="keyword">return</span> s-&gt;arr[s-&gt;top];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传进来的数必须满足 =  2 ^ n - 1 </span></span><br><span class="line"><span class="function">Tree <span class="title">initTree</span><span class="params">(<span class="keyword">int</span> nodeCounts)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个操作仅仅是让p指向申请的那块空间的首地址，p不是树的头指针</span></span><br><span class="line">    Tree p = (Tree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TreeNode) * (nodeCounts + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nodeCounts; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p[i].data = i;</span><br><span class="line">        p[i].tag = unvisit;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nodeCounts / <span class="number">2</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p[i].left = p + <span class="number">2</span> * i;</span><br><span class="line">        p[i].right = p + <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nodeCounts / <span class="number">2</span> + <span class="number">1</span>; i &lt;= nodeCounts; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p[i].left = <span class="literal">NULL</span>;</span><br><span class="line">        p[i].right = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>后序遍历</tag>
      </tags>
  </entry>
</search>
