<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C语言基础</title>
    <url>/2020/06/02/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h3 id="在读入字符-字符串时需要注意的问题"><a href="#在读入字符-字符串时需要注意的问题" class="headerlink" title="在读入字符/字符串时需要注意的问题"></a>在读入字符/字符串时需要注意的问题</h3><blockquote>
<p>HDOJ 2091 一道水题，硬是给上了一课，主要还是C语言基础不扎实，对于字符/字符串的的多次输入时应该注意的问题仍然理解不透彻，当我用我的一贯做法： <code>stdlib.h</code> 里的 <code>fflush(stdin)</code>来清理输入缓存区，得到的结果是 Output Limit Exceeded  ， T^T，明明效果是一样的，为什么过不了。后来用<code>getchar()</code>来清输入缓存区，成功AC，目前还不知道这两个的原理究竟有何不同，有时间深挖一下。 </p>
</blockquote>
<ul>
<li><code>scanf()</code>和<code>getchar()</code>不可以吸收后面的回车，若其后还有字符或字符串输入，中间需要用<code>getchar()</code>来吸收回车</li>
<li><code>gets()</code>以回车作为一串字符的结束标志，并将回车改为<code>&#39;\0&#39;</code>存入，因此<code>gets()</code>读取在字符串时，可以自动吸收回车</li>
<li><code>getchar()</code>只可以用来接收字符，<code>gets()</code>只能接收字符串</li>
</ul>
]]></content>
      <categories>
        <category>C语言基础</category>
      </categories>
      <tags>
        <tag>C语言基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Encrypted Article</title>
    <url>/2020/06/16/ExpressMyMind/</url>
    <content><![CDATA[<p>Encrypted Article ! </p>
<p>Please click the “Read All Text” button below.</p>
<a id="more"></a>

<p>还记得四年前的八月十三号晚上，还有两天就要去武邑上学了，我……想表达一下心里憋了挺久的想法，然后…….我跟你开了个所谓的玩笑，也不知道你还记不记得那个玩笑呵呵呵，就当你还记得吧，说是玩笑，其实还是我当时怂了，说出去以后马上就又不敢承认了，当时还编造各种借口，来证明那只是一个玩笑。上了高中以后，高一寒假我又跟你重申了一下那是个玩笑，现在想起来都挺好笑的呵呵。</p>
<p>也许你知道我当时是认真的，然后拒绝了我；也许你真的以为那是个玩笑。</p>
<p>无论如何，现在，我承认，那是我的真心话，那时候是，现在也是。</p>
<p>所以，我们可以互相了解了解吗？</p>
]]></content>
  </entry>
  <entry>
    <title>HDOJ 2092</title>
    <url>/2020/05/30/HDOJ-2092/</url>
    <content><![CDATA[<h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>有二个整数，它们加起来等于某个整数，乘起来又等于另一个整数，它们到底是真还是假，也就是这种整数到底存不存在，实在有点吃不准，你能快速回答吗？看来只能通过编程。<br>例如：<br>x + y = 9，x * y = 15 ? 找不到这样的整数x和y<br>1+4=5，1*4=4，所以，加起来等于5，乘起来等于4的二个整数为1和4<br>7+(-8)=-1，7*（-8）=-56，所以，加起来等于-1，乘起来等于-56的二个整数为7和-8</p>
<a id="more"></a>

<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入数据为成对出现的整数n，m（-10000&lt;n,m&lt;10000），它们分别表示整数的和与积，如果两者都为0，则输入结束。</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>只需要对于每个n和m，输出“Yes”或者“No”，明确有还是没有这种整数就行了。</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">9 15</span><br><span class="line">5 4</span><br><span class="line">1 -56</span><br><span class="line">0 0</span><br></pre></td></tr></table></figure>



<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">No</span><br><span class="line">Yes</span><br><span class="line">Yes</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote>
<p>网上呢，大部分都是暴力枚举或者是解二次方程的方法，个人写了另外的一种解法（比较绕，情况比较多，细分下来有五种情况）</p>
</blockquote>
<p>这个题呢，说到底就是找 <code>y</code> 的因数，找到因数一切就都好办了。</p>
<ul>
<li>先来考虑<code>y</code>是正数的情况。一个正数的因数可以是两个负数，也可以是两个正数。<ul>
<li><strong>操作1</strong> ：  如果<code>x</code>是正数，那么要找的满足条件的<code>y</code>的两个因数都是正数。从 1 开始遍历小于等于<code>sqrt(y)</code>（根号y）的所有正整数，依次找到<code>y</code>的因数，然后用<code>y</code>除以这个因数找到另一个因数。这样的话两个因数就找全了。再对两数之和是否等于<code>x</code>进行判断即可。</li>
<li><strong>操作2</strong> ：  如果<code>x</code>是负数，那么要找的满足条件的<code>y</code>的两个因数都是负数，先进行操作1 找到两个正的因数，再判断这两个正的因数的和是否等于<code>-x</code>即可。</li>
</ul>
</li>
<li>如果<code>y</code>是负数呢？当<code>y</code>是负数的时，只能拆成一个正因子一个负因子，但是也会有两种情况，比如 <code>-56</code>可以拆成 <code>-7 、 8</code>，也可以拆成<code>7 、-8</code>  ，在这里只要把   <code>y</code>是变成正数执行<strong>操作1</strong>，然后再给找到的两个因数分配负号即可。<strong>操作1</strong>进行结束以后，假设找到两个因数 <code>a</code> 和<code>b</code> ，然后分配负号，要么分配给<code>a</code>，要么分配给<code>b</code>，因此 <code>-a + b</code> 和   <code>a + (-b)</code>之间，只要满足有一个的和为<code>x</code>即满足题目条件。</li>
<li>考虑完以上两种情况之后，还少一种情况，那就是<code>y = 0</code>时，<code>y</code> 是 <code>0</code> 的时候，<code>x</code>无论是什么值，必定存在这样的两个整数(一个是 0 ，另外一个的值等于x )满足题目的条件。</li>
</ul>
<hr>
<h3 id="AC代码附上"><a href="#AC代码附上" class="headerlink" title="AC代码附上"></a>AC代码附上</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, n, m, flag1, flag2;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;m, &amp;n) &amp;&amp; (m || n))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        flag1 = <span class="number">1</span>;</span><br><span class="line">        flag2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            flag2 = <span class="number">1</span>;</span><br><span class="line">            n *= <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="built_in">sqrt</span>(n); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (n % i == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (flag2) <span class="comment">// 负数算法</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((i * (<span class="number">-1</span>) + n / i == m) || (i + (n / i) * (<span class="number">-1</span>) == m))</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">"Yes"</span>);</span><br><span class="line">                        flag1 = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!flag2) <span class="comment">// 正数算法</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (((i + n / i) == m) || ((i + n / i) == (<span class="number">-1</span>) * m))</span><br><span class="line">                    &#123;</span><br><span class="line">                        flag1 = <span class="number">0</span>;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">"Yes"</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag1)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"No"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Program-lessons"><a href="#Program-lessons" class="headerlink" title="Program lessons ++"></a>Program lessons ++</h3><ul>
<li>题目要求的printf形式是<code>Yes</code>和<code>No</code>，然而我在做这道题的时候printf的是<code>YES</code>和<code>NO</code>，导致一直无法AC，差点自闭。</li>
<li>细节决定 A / W。</li>
</ul>
]]></content>
      <categories>
        <category>HDOJ</category>
      </categories>
      <tags>
        <tag>HDOJ</tag>
      </tags>
  </entry>
  <entry>
    <title>初窥链表</title>
    <url>/2020/06/07/%E5%88%9D%E7%AA%A5%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h3 id="作文缘由"><a href="#作文缘由" class="headerlink" title="作文缘由"></a>作文缘由</h3><ul>
<li>为了让处在水深火热之中的广大C语言初学者少踩坑，写下此文，希望给后来者指一下方向。</li>
<li>第一篇稍微有点技术含量的博客，昨天下午看完了男神丁的链表课，看完就嘿嘿嘿，链表也不过如此嘛，晚上九点多打开雪梨任务开始做第三题，结果……呵呵呵。通过昨天下午的学习和做完第一道链表的水题，写点东西来总结一下自己的收获。</li>
</ul>
<a id="more"></a>

<h3 id="一些建议"><a href="#一些建议" class="headerlink" title="一些建议"></a>一些建议</h3><p>纸上自己画画，琢磨琢磨，不要怀疑自己的智商，那只会浪费时间降低思考效率。</p>
<h3 id="容易混淆-懵圈-的地方"><a href="#容易混淆-懵圈-的地方" class="headerlink" title="容易混淆(懵圈)的地方"></a>容易混淆(懵圈)的地方</h3><p>链表嘛，其实就是结构体+指针，然而不知道有多少人跪了= =</p>
<ul>
<li>指向首结点的指针只是一个单纯的指针，这个指针存的是首结点的地址</li>
<li>要分清什么是结点的地址，什么是结点的指针域，指针域又是什么？指针域的值是下一个结点的地址。说着都挺简单的，反正我这个菜鸡当时是绕进去了。就是三个东西，一个是当前结点本身这个大东西的地址；还有一个是，当前结点自身这个大东西的地址被存在上一个结点的指针域里；最后一个是，结构体内部的指针域还存着一个地址，是下一个结点的地址。  除去一些细枝末节的东西，这三个东西差不多就是链表相互之间联系的桥梁。  此外，还要分清楚： 什么是结点类型（即声明的结构体类型）的指针变量，什么是结点类型。</li>
<li>在用temp遍历结点的时候，要知道temp = 当前结构体的指针域，也代表temp指向下一个结点那个大东西的地址，具体请看下方<code>对于两段代码的思考</code></li>
</ul>
<h3 id="数据域尽量使用结构体，不要单独开变量"><a href="#数据域尽量使用结构体，不要单独开变量" class="headerlink" title="数据域尽量使用结构体，不要单独开变量"></a>数据域尽量使用结构体，不要单独开变量</h3><p>为什么要这么说呢，在做作业swap函数的时候，我的第一个思路是直接把相应结点的地址换了就行了呗。</p>
<p>然而，事情没有想象的那么简单。变量的地址还能换？？？怎么换？？？我这个菜鸡目前还不会 hhh</p>
<p>所以，我又想了，并且想的又全面了一点。要换俩结点的数据域，无非就是让第<code>i-1</code>个结点的指针域是第<code>j</code>个结点的地址，让第<code>j</code>个结点的指针域等于第<code>i</code>个结点的指针域，让第<code>j-1</code>的指针域是第<code>i</code>个结点的地址，让第<code>i</code>个结点的指针域等于第<code>j</code>个结点的指针域。 在这期间还需要开中间变量来存第<code>j</code>个结点的指针域。<strong>我去，真麻烦，呸！</strong>然后我又想了一下，这仅仅是一种普通情况，呵呵呵，事情远远没有想象的那么简单</p>
<p>在这里规定结点数为<code>n</code>，个人想出来几种想的到的<code>子情况</code>（欢迎大佬补充），要交换数据域的两个结点是第<code>i</code>个和第<code>j</code>个，在这里规定<code>i &lt; j</code></p>
<blockquote>
<ul>
<li>n &gt; 3, 两个结点中间相隔的结点数 &gt;= 1， 且都不是首结点。就是上边说的情况。</li>
<li>两个结点是相邻的。上述做法就不可行了，直接让第i - 1 个结点的指针域等于第j个结点的地址，让第j个结点的指针域等于第i个结点的地址，让第i个结点的指针域等于第j个结点的指针域即可。</li>
<li>要交换的两个结点中，前者是首结点。首结点前面是没有结点的，因此需要让指向首结点的指针等于第 j个结点的地址。</li>
</ul>
<p>列出是子情况，它们还可以组成其它情况： 例如 n = 2 时，是第二个情况和第三个情况的综合</p>
</blockquote>
<h5 id="行了，扯了一大堆，让我们回到正题。-有没有被这种直接对地址的操作恶心到？"><a href="#行了，扯了一大堆，让我们回到正题。-有没有被这种直接对地址的操作恶心到？" class="headerlink" title="行了，扯了一大堆，让我们回到正题。  有没有被这种直接对地址的操作恶心到？"></a>行了，扯了一大堆，让我们回到正题。  有没有被这种直接对地址的操作恶心到？</h5><p>所以，以后敲代码的时候，数据域还是使用结构体吧 = = 。这样的话，直接找到两个结点的地址，对地址寻址交换它们的数据域就妥了，结构体可以直接相互赋值还是很舒服的。如果前人的代码，数据域里都是单独的变量，如果单独的变量不多，还是建议一个一个得去交换单独的变量，因为如果你想操作地址…呵呵呵，请看上面，你都要考虑到。</p>
<h3 id="对于两段代码的思考"><a href="#对于两段代码的思考" class="headerlink" title="对于两段代码的思考"></a>对于两段代码的思考</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// temp是首结点的地址</span></span><br><span class="line"><span class="keyword">while</span> (temp-&gt;Next != <span class="literal">NULL</span>)</span><br><span class="line">     temp = temp-&gt;Next;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// temp是首结点的地址</span></span><br><span class="line"><span class="keyword">while</span> (temp != <span class="literal">NULL</span>)</span><br><span class="line">     temp = temp-&gt;Next</span><br></pre></td></tr></table></figure>

<p>在遍历链表的时候我有了个疑惑，这俩究竟有啥区别？？</p>
<p>对于一个菜鸡来说，思考的过程无疑是痛苦的，所以，我痛苦了很久，想出来了</p>
<p>然而，没什么好痛苦的，千万不要怀疑自己的智商，越怀疑越痛苦越是想不出来</p>
<p>如果我不怀疑自己的话，也许= =   ， 一想就出来了。</p>
<p>好了，建议拿出纸和笔来写写画画，研究一波。</p>
<hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// temp是一个结点类型的指针变量，存储首结点的地址</span></span><br><span class="line"><span class="keyword">while</span> (temp-&gt;Next != <span class="literal">NULL</span>)</span><br><span class="line">     temp = temp-&gt;Next;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>这种判断方式可以理解为：先判当前结点的指针域（即下一个结点的地址）是不是NULL，若是，则指向下一个结点，否则指针的指向停在当前结点处。</p>
</li>
<li><p>由于是从第二个结点开始判断其是不是空指针NULL，因此会漏掉第一个结点，如果你的链表第一个结点的地址是一个空指针NULL，则会报错。</p>
</li>
<li><p><strong>最后是temp的值是尾结点的地址</strong></p>
</li>
</ul>
<p>要注意，这种方法，当指针指向最后一个结点时，会直接终止，并不会对最后一个结点做任何操作</p>
<p>如果想在while循环里记录最后一个结点的数据域，那么这个方法是行不通的</p>
<p>它只可以得到最后一个结点的地址，如果想得到最后一个结点的数据域，需要在循环后面加上这样一段代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  t 为存储数据域的中间变量</span></span><br><span class="line">t = temp-&gt;data</span><br></pre></td></tr></table></figure>



<hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// temp是一个结点类型的指针变量，存储首结点的地址</span></span><br><span class="line"><span class="keyword">while</span> (temp != <span class="literal">NULL</span>)</span><br><span class="line">     temp = temp-&gt;Next</span><br></pre></td></tr></table></figure>

<ul>
<li><p>这种判断方式可以理解为: 先判断当前结点自身的地址是不是NULL，如果不是，令temp等于对指针域里的地址寻址得到的那个地址(简单说，就是将下一个结点的地址赋值给temp)，否则，指针的指向停在当前。</p>
</li>
<li><p>所以，当temp的值是末尾结点的地址的时候，它判断这个值(末尾结点的地址)是不是NULL，显然，不是，然后temp会被赋值为NULL，循环终止。</p>
</li>
<li><p>所以，<strong>最后temp的值是NULL</strong> , 这种办法得不到最后一个结点的地址, 但是可以在while循环里记录最后一个结点的数据域。不必像上边的代码一样等循环终止了再加上一段代码来记录。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构-链表</category>
      </categories>
      <tags>
        <tag>数据结构-链表</tag>
      </tags>
  </entry>
</search>
